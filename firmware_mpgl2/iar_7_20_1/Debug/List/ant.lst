###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        20/Jun/2015  15:02:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpg_common\drivers\ant.c
#    Command line =  
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpg_common\drivers\ant.c
#        --preprocess=cl
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\ -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpgl2\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

C:\Users\Vipin\Documents\GitHub\mpgl2\firmware_mpg_common\drivers\ant.c
      1          /***********************************************************************************************************************
      2          File: ant.c                                                               
      3          
      4          Description:
      5          ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  This driver requires synchronous
      6          SPI slave connection to an AP2 or AP2-emulated ANT device (the ANT device is the Master).  
      7          All interface layer code is maintained here.  
      8          Transmitted messages use the Message task; received messages use an SSP peripheral
      9          with SPI_SLAVE_FLOW_CONTROL.
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          
     13          Protected System functions:
     14          void AntInitialize(void)
     15          void AntRunActiveState(void)
     16          
     17          ***********************************************************************************************************************/
     18          
     19          #include "configuration.h"
     20          
     21          /***********************************************************************************************************************
     22          * Bookmarks
     23          ************************************************************************************************************************
     24          !!!!! ANT Serial-layer Functions
     25          @@@@@ ANT Interface-layer Functions
     26          ##### ANT State Machine Definition                                             
     27          ***********************************************************************************************************************/
     28          
     29          /***********************************************************************************************************************
     30          Global variable definitions with scope across entire project.
     31          All Global variable names shall start with "G_<type>Ant"
     32          ***********************************************************************************************************************/
     33          
     34          /* New variables */

   \                                 In section .bss, align 4
     35          u32 G_u32AntFlags;                            /* Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \   00000000                      DS8 4
     36          

   \                                 In section .bss, align 4
     37          AntSetupDataType G_stAntSetupData;            /* ANT channel configuration data */
   \                     G_stAntSetupData:
   \   00000000                      DS8 12
     38          

   \                                 In section .bss, align 4
     39          AntApplicationMsgListType *G_sAntApplicationMsgList;  /* Public linked list of messages from ANT to the application */
   \                     G_sAntApplicationMsgList:
   \   00000000                      DS8 4
     40          

   \                                 In section .data, align 4
     41          u8 G_au8AntMessageOk[]   = "OK\n\r";
   \                     G_au8AntMessageOk:
   \   00000000   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     42          u8 G_au8AntMessageFail[] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \   00000000   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .data, align 4
     43          u8 G_au8AntMessageAssign[] = "ANT channel assign ";
   \                     G_au8AntMessageAssign:
   \   00000000   0x41 0x4E          DC8 "ANT channel assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     44          u8 G_au8AntMessageUnassign[] = "ANT channel unassign ";
   \                     G_au8AntMessageUnassign:
   \   00000000   0x41 0x4E          DC8 "ANT channel unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     45          u8 G_au8AntMessageUnhandled[] = "Default Channel Response ";
   \                     G_au8AntMessageUnhandled:
   \   00000000   0x44 0x65          DC8 "Default Channel Response "
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x43 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x52 0x65    
   \              0x73 0x70    
   \              0x6F 0x6E    
   \              0x73 0x65    
   \              0x20 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     46          u8 G_au8AntMessageSetup[] = "ANT channel setup ";
   \                     G_au8AntMessageSetup:
   \   00000000   0x41 0x4E          DC8 "ANT channel setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .data, align 4
     47          u8 G_au8AntMessageClose[] = "ANT channel close ";
   \                     G_au8AntMessageClose:
   \   00000000   0x41 0x4E          DC8 "ANT channel close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .data, align 4
     48          u8 G_au8AntMessageOpen[]  = "ANT channel open ";
   \                     G_au8AntMessageOpen:
   \   00000000   0x41 0x4E          DC8 "ANT channel open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     49          u8 G_au8AntMessageInit[] = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \   00000000   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     50          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \   00000000   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .data, align 4
     51          u8 G_au8AntMessageNoAnt[] = "\n\r### nRF51422 Programming Mode: no ANT functionality ####\n\r";
   \                     G_au8AntMessageNoAnt:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 23H, 20H, 6EH, 52H
   \              0x23 0x23    
   \              0x23 0x20    
   \              0x6E 0x52    
   \   00000008   0x46 0x35          DC8 46H, 35H, 31H, 34H, 32H, 32H, 20H, 50H
   \              0x31 0x34    
   \              0x32 0x32    
   \              0x20 0x50    
   \   00000010   0x72 0x6F          DC8 72H, 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x6D 0x69    
   \   00000018   0x6E 0x67          DC8 6EH, 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x3A    
   \   00000020   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H
   \              0x6F 0x20    
   \              0x41 0x4E    
   \              0x54 0x20    
   \   00000028   0x66 0x75          DC8 66H, 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000030   0x61 0x6C          DC8 61H, 6CH, 69H, 74H, 79H, 20H, 23H, 23H
   \              0x69 0x74    
   \              0x79 0x20    
   \              0x23 0x23    
   \   00000038   0x23 0x23          DC8 23H, 23H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     52          
     53          
     54          /*----------------------------------------------------------------------------*/
     55          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     56          and indicate what file the variable is defined in. */
     57          extern u32 G_u32SystemFlags;                            /* From main.c */
     58          extern u32 G_u32ApplicationFlags;                       /* From main.c */
     59          
     60          extern volatile u32 G_u32SystemTime1ms;                 /* From board-specific source file */
     61          extern volatile u32 G_u32SystemTime1s;                  /* From board-specific source file */
     62          
     63          extern volatile u32 ANT_SSP_FLAGS;                      /* From configuration.h */
     64          
     65          
     66          /***********************************************************************************************************************
     67          Global variable definitions with scope limited to this local application.
     68          Variable names shall start with "Ant_<type>Name" and be declared as static.
     69          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     70          static fnCode_type Ant_pfnStateMachine;                 /* The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     71          static u32 Ant_u32RxTimeoutCounter;                     /* Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimeoutCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     72          static u32 Ant_u32TxTimeoutCounter;                     /* Dedicated timer for transmitting bytes */
                            ^
Warning[Pe550]: variable "Ant_u32TxTimeoutCounter" was set but never used
   \                     Ant_u32TxTimeoutCounter:
   \   00000000                      DS8 4
     73          

   \                                 In section .bss, align 4
     74          static u32 Ant_u32TxByteCounter = 0;                    /* Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     75          static u32 Ant_u32RxByteCounter = 0;                    /* Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     76          static u32 Ant_u32UnexpectedByteCounter = 0;            /* Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     77          static u32 Ant_u32CurrentTxMessageToken = 0;            /* Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \   00000000                      DS8 4
     78          

   \                                 In section .bss, align 4
     79          static SspConfigurationType Ant_sSspConfig;             /* Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     80          static SspPeripheralType* Ant_Ssp;                      /* Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \   00000000                      DS8 4
     81          

   \                                 In section .bss, align 4
     82          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /* ANT device version string */
   \                     Ant_u8AntVersion:
   \   00000000                      DS8 12
     83          

   \                                 In section .bss, align 4
     84          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /* Space for verified received ANT messages */
   \                     Ant_au8AntRxBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
     85          static u8 *Ant_pu8AntRxBufferNextChar;                  /* Pointer to next char to be written in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     86          static u8 *Ant_pu8AntRxBufferCurrentChar;               /* Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     87          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /* Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     88          static u8 Ant_u8AntNewRxMessages;                       /* Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \   00000000                      DS8 1
     89          

   \                                 In section .bss, align 4
     90          static AntOutgoingMessageListType *Ant_psDataOutgoingMsgList; /* Linked list of outgoing ANT-formatted messages */
   \                     Ant_psDataOutgoingMsgList:
   \   00000000                      DS8 4
     91          

   \                                 In section .bss, align 1
     92          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     93          static u8 Ant_u8SlaveMissedMessageMid = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     94          static u8 Ant_u8SlaveMissedMessageLow = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \   00000000                      DS8 1
     95          
     96          
     97          /* Debug variables */

   \                                 In section .bss, align 4
     98          static u32 Ant_DebugRxMessageCounter = 0;
   \                     Ant_DebugRxMessageCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     99          static u32 Ant_DebugTotalRxMessages = 0;
   \                     Ant_DebugTotalRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Ant_DebugProcessRxMessages = 0;
   \                     Ant_DebugProcessRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Ant_DebugQueuedDataMessages = 0;
   \                     Ant_DebugQueuedDataMessages:
   \   00000000                      DS8 4
    102          static u32 Ant_DebugUnexpectedRxByte = 0;
                            ^
Warning[Pe177]: variable "Ant_DebugUnexpectedRxByte" was declared but never
          referenced
    103          
    104          
    105          /***********************************************************************************************************************
    106          !!!!! ANT Serial-layer Functions
    107          ***********************************************************************************************************************/
    108          
    109          /* ANT Private Serial-layer Functions */
    110          
    111          /*------------------------------------------------------------------------------
    112          Function: AntSyncSerialInitialize
    113          
    114          Description:
    115          Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
    116          
    117          Requires:
    118            - ANT_SPI is configured
    119            - !CS (SEN) interrupt should be enabled
    120          // - GPIO interrupts are configured and enabled
    121          
    122          Promises:
    123            - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
    124            - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
    125            - Ant_u8AntNewRxMessages = 0;
    126            - ANT SSP CS and RX interrupts are enabled
    127            - If ANT starts up correctly and responds to version request, then 
    128              G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
    129              with the returned version information from the ANT IC.  
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          static void AntSyncSerialInitialize(void)
    132          {
   \                     AntSyncSerialInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    133            u8 au8ANTGetVersion[] = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, G_stAntSetupData.AntChannel, MESG_VERSION_ID, 0};    
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12
   \   0000000A   0xC90C             LDM      R1!,{R2,R3}
   \   0000000C   0xC00C             STM      R0!,{R2,R3}
   \   0000000E   0x3908             SUBS     R1,R1,#+8
   \   00000010   0x3808             SUBS     R0,R0,#+8
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF88D 0x0006      STRB     R0,[SP, #+6]
    134            u32 u32EventTimer;
    135            bool bErrorStatus = FALSE;
   \   0000001C   0x2400             MOVS     R4,#+0
    136            
    137            /* Initialize buffer pointers */  
    138            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000026   0x6008             STR      R0,[R1, #+0]
    139            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000030   0x6008             STR      R0,[R1, #+0]
    140            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    141            Ant_u8AntNewRxMessages = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    142           
    143            /* Reset the 51422 and initialize SRDY and MRDY */
    144            u32EventTimer = G_u32SystemTime1ms;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    145            ANT_RESET_ASSERT();
   \   0000004C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   00000054   0x6008             STR      R0,[R1, #+0]
    146            SYNC_MRDY_DEASSERT();
   \   00000056   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    147            SYNC_SRDY_DEASSERT();
   \   00000060   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   00000068   0x6008             STR      R0,[R1, #+0]
    148            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \   0000006A   0x2164             MOVS     R1,#+100
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       IsTimeUp
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
    149            ANT_RESET_DEASSERT();
   \   00000076   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    150            u32EventTimer = G_u32SystemTime1ms;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x9000             STR      R0,[SP, #+0]
    151            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \   00000088   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       IsTimeUp
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
    152          
    153            
    154            /* ANT should want to send message 0x6F now to indicate it has reset */
    155            u32EventTimer = G_u32SystemTime1ms;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x9000             STR      R0,[SP, #+0]
    156            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x07C0             LSLS     R0,R0,#+31
   \   000000A6   0xD409             BMI.N    ??AntSyncSerialInitialize_3
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2C00             CMP      R4,#+0
   \   000000AC   0xD106             BNE.N    ??AntSyncSerialInitialize_3
    157            {
    158              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \   000000AE   0xF241 0x3188      MOVW     R1,#+5000
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      BL       IsTimeUp
   \   000000B8   0x0004             MOVS     R4,R0
   \   000000BA   0xE7F0             B.N      ??AntSyncSerialInitialize_2
    159            }
    160          
    161            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD118             BNE.N    ??AntSyncSerialInitialize_4
    162            {
    163              /* Receive and process the restart message */
    164              AntRxMessage();
   \   000000C2   0x.... 0x....      BL       AntRxMessage
    165              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    166              AntProcessMessage();   
   \   000000D6   0x.... 0x....      BL       AntProcessMessage
    167              
    168              /* Send out version request message and expect response */
    169              au8ANTGetVersion[4] = AntCalculateTxChecksum(&au8ANTGetVersion[0]);
   \   000000DA   0xA801             ADD      R0,SP,#+4
   \   000000DC   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000E0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    170              AntTxMessage(&au8ANTGetVersion[0]);    
   \   000000E4   0xA801             ADD      R0,SP,#+4
   \   000000E6   0x.... 0x....      BL       AntTxMessage
    171              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \   000000EA   0xF241 0x3188      MOVW     R1,#+5000
   \   000000EE   0x203E             MOVS     R0,#+62
   \   000000F0   0x.... 0x....      BL       AntExpectResponse
    172            }
    173           
    174          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_4: (+1)
   \   000000F4   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    
    175          
    176          
    177          /*-----------------------------------------------------------------------------
    178          Function: AntRxMessage
    179          
    180          Description:
    181          Receive a message from ANT to the Host.  Incoming bytes are deposited directly into the receive
    182          buffer from the SSP ISR which should be extremely fast.  
    183          
    184          Requires:
    185            - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    186            - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    187              but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    188              been received); _SSP_RX_COMPLETE must still be set from this.
    189            - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    190          
    191          Promises:
    192            - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    193              and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    194            - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    195            - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    196          */

   \                                 In section .text, align 2, keep-with-next
    197          static void AntRxMessage(void)
    198          {
   \                     AntRxMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    199            u8 u8Checksum;
    200            u8 u8Length;
    201            u32 u32CurrentRxByteCount;
    202            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    203           
    204            /* Ensure we have CS flag */
    205            if( !( IS_SEN_ASSERTED() ) )
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xF140 0x80EC      BPL.W    ??AntRxMessage_0
    206            {
    207              return;
    208            }
    209            
    210            /* Initialize the receive timer and get a snapshot of current byte count */
    211            //u32CurrentRxByteCount = 0;
    212            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0006             MOVS     R6,R0
    213            Ant_u32RxTimeoutCounter = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    214            
    215            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    216            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x00C0             LSLS     R0,R0,#+3
   \   00000034   0xD509             BPL.N    ??AntRxMessage_2
    217            {
    218              /* Clear flag and load the value we know was already received to allow the function to proceed*/
    219              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000044   0x6008             STR      R0,[R1, #+0]
    220              
    221              /* Adjust the starting byte counter since it came in during AntTxMessage */
    222              u32CurrentRxByteCount--;
   \   00000046   0x1E76             SUBS     R6,R6,#+1
   \   00000048   0xE023             B.N      ??AntRxMessage_3
    223              
    224            }
    225            /* Otherwise we need to first read the sync byte  */
    226            else
    227            {
    228              /* Do short delay then cycle SRDY to get the first byte */
    229              for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     ??AntRxMessage_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??AntRxMessage_4: (+1)
   \   0000004C   0xF5B0 0x7F96      CMP      R0,#+300
   \   00000050   0xD201             BCS.N    ??AntRxMessage_5
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xE7FA             B.N      ??AntRxMessage_4
    230              SYNC_SRDY_ASSERT();
   \                     ??AntRxMessage_5: (+1)
   \   00000056   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    231              SYNC_SRDY_DEASSERT();    
   \   00000060   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   00000068   0x6008             STR      R0,[R1, #+0]
    232          
    233              /* Begin the receive cycle that is monitored by a timeout of about 500us - this should be plenty of time
    234              to receive even the longest ANT message but still only half the allowed 1ms loop time for the system. */
    235              
    236              /* Read the first byte when it comes in */
    237              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    238                     (Ant_u32RxTimeoutCounter < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_6: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0700             LSLS     R0,R0,#+28
   \   00000072   0xD40E             BMI.N    ??AntRxMessage_3
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xf4240
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD207             BCS.N    ??AntRxMessage_3
    239              {
    240                Ant_u32RxTimeoutCounter++;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \   00000090   0xE7EB             B.N      ??AntRxMessage_6
    241              }
    242            }
    243            
    244            if( Ant_u32RxTimeoutCounter > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0xf4241
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD30D             BCC.N    ??AntRxMessage_7
    245            {
    246              AntAbortMessage();
   \   000000A0   0x.... 0x....      BL       AntAbortMessage
    247              DebugPrintf(au8RxTimeoutMsg);
   \   000000A4   0xA800             ADD      R0,SP,#+0
   \   000000A6   0x.... 0x....      BL       DebugPrintf
    248              ANT_SSP_FLAGS &= ~_SSP_CS_ASSERTED;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x0840             LSRS     R0,R0,#+1
   \   000000B2   0x0040             LSLS     R0,R0,#+1
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    249              return;
   \   000000BA   0xE09B             B.N      ??AntRxMessage_0
    250            }
    251          
    252            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    253            The callback does NOT toggle SRDY yet because the CS_ASSERTED flag will 
    254            still be set indicating that this is the first byte. 
    255            CS_ASSERTED and _SSP_RX_COMPLETE should still
    256            be set from AntTxMessage if that's what got us here. */
    257            ANT_SSP_FLAGS &= ~(_SSP_RX_COMPLETE | _SSP_CS_ASSERTED);
   \                     ??AntRxMessage_7: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF030 0x0009      BICS     R0,R0,#0x9
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    258             
    259            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    260            Proceed to test it and receive the rest of the message */
    261            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x28A4             CMP      R0,#+164
   \   000000D6   0xF040 0x8080      BNE.W    ??AntRxMessage_8
    262            {
    263              /* Flag that a reception is in progress */
    264              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000E8   0x6008             STR      R0,[R1, #+0]
    265              
    266              /* Cycle SRDY to get the next byte (length) */
    267              for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \   000000EA   0x2000             MOVS     R0,#+0
   \                     ??AntRxMessage_9: (+1)
   \   000000EC   0xF5B0 0x7F96      CMP      R0,#+300
   \   000000F0   0xD201             BCS.N    ??AntRxMessage_10
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0xE7FA             B.N      ??AntRxMessage_9
    268              SYNC_SRDY_ASSERT();
   \                     ??AntRxMessage_10: (+1)
   \   000000F6   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    269              SYNC_SRDY_DEASSERT();   
   \   00000100   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   00000108   0x6008             STR      R0,[R1, #+0]
    270              
    271              /* The SSP interrupts and Rx callback handle the rest of the reception until a full message is received. 
    272              We know it is received when SSP_CS_DEASSERTED is flagged. */
    273              while( !(ANT_SSP_FLAGS & _SSP_CS_DEASSERTED) &&
    274                     (Ant_u32RxTimeoutCounter < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_11: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0x0780             LSLS     R0,R0,#+30
   \   00000112   0xD40E             BMI.N    ??AntRxMessage_12
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xf4240
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xD207             BCS.N    ??AntRxMessage_12
    275              {
    276                Ant_u32RxTimeoutCounter++;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000012E   0x6008             STR      R0,[R1, #+0]
   \   00000130   0xE7EB             B.N      ??AntRxMessage_11
    277              }
    278             
    279              /* Check that the above loop ended as expected and didn't time out */
    280              if(ANT_SSP_FLAGS & _SSP_CS_DEASSERTED)
   \                     ??AntRxMessage_12: (+1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x0780             LSLS     R0,R0,#+30
   \   0000013A   0xD559             BPL.N    ??AntRxMessage_13
    281              {  
    282                /* Clear flags */
    283                ANT_SSP_FLAGS &= ~(_SSP_RX_COMPLETE | _SSP_CS_DEASSERTED);
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0xF030 0x000A      BICS     R0,R0,#0xA
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000014A   0x6008             STR      R0,[R1, #+0]
    284                
    285                /* Update counter to see how many bytes we should have */
    286                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x1B86             SUBS     R6,R0,R6
    287              
    288                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    289                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x7800             LDRB     R0,[R0, #+0]
   \   0000015C   0x0004             MOVS     R4,R0
    290                AdvanceAntRxBufferCurrentChar();
   \   0000015E   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    291                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x7800             LDRB     R0,[R0, #+0]
   \   0000016A   0x1C80             ADDS     R0,R0,#+2
   \   0000016C   0x0005             MOVS     R5,R0
    292                
    293                /* Optional check */
    294                if(u32CurrentRxByteCount != (u8Length + 2) )
   \   0000016E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000170   0x1CA8             ADDS     R0,R5,#+2
   \   00000172   0x4286             CMP      R6,R0
   \   00000174   0xD007             BEQ.N    ??AntRxMessage_14
    295                {
    296                  /* Could throw out the message right away - this could save some potential weird memory accesses
    297                  if there was any corruption or a wild u8Length value */
    298                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000184   0x6008             STR      R0,[R1, #+0]
    299                }
    300           
    301                /* Validate the remaining bytes based on the u8Length*/
    302                do
    303                {
    304                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_14: (+1)
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000018A   0x6800             LDR      R0,[R0, #+0]
   \   0000018C   0x7800             LDRB     R0,[R0, #+0]
   \   0000018E   0x4044             EORS     R4,R0,R4
    305                  AdvanceAntRxBufferCurrentChar();
   \   00000190   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    306                } while (--u8Length);
   \   00000194   0x1E6D             SUBS     R5,R5,#+1
   \   00000196   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000198   0x2D00             CMP      R5,#+0
   \   0000019A   0xD1F4             BNE.N    ??AntRxMessage_14
    307                
    308                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    309                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0x7800             LDRB     R0,[R0, #+0]
   \   000001A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A6   0x4284             CMP      R4,R0
   \   000001A8   0xD10E             BNE.N    ??AntRxMessage_15
    310                {
    311                  Ant_u8AntNewRxMessages++;
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000001AE   0x7800             LDRB     R0,[R0, #+0]
   \   000001B0   0x1C40             ADDS     R0,R0,#+1
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   000001B6   0x7008             STRB     R0,[R1, #+0]
    312                  Ant_DebugTotalRxMessages++;
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000001BC   0x6800             LDR      R0,[R0, #+0]
   \   000001BE   0x1C40             ADDS     R0,R0,#+1
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   000001C4   0x6008             STR      R0,[R1, #+0]
   \   000001C6   0xE013             B.N      ??AntRxMessage_13
    313                }
    314                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    315                else
    316                {
    317                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_15: (+1)
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   000001D2   0x6008             STR      R0,[R1, #+0]
    318                  AdvanceAntRxBufferUnreadMsgPointer();
   \   000001D4   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \   000001D8   0xE00A             B.N      ??AntRxMessage_13
    319                }
    320              } 
    321            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    322            else
    323            {
    324              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    325              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_8: (+1)
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \   000001DE   0x6800             LDR      R0,[R0, #+0]
   \   000001E0   0x1C40             ADDS     R0,R0,#+1
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \   000001E6   0x6008             STR      R0,[R1, #+0]
    326              ANT_SSP_FLAGS = 0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001EE   0x6008             STR      R0,[R1, #+0]
    327            }
    328          
    329            /* In all cases, finish by advancing the current byte pointer */
    330            AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \   000001F0   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    331            
    332          } /* end AntRxMessage() */
   \                     ??AntRxMessage_0: (+1)
   \   000001F4   0xB006             ADD      SP,SP,#+24
   \   000001F6   0xBD70             POP      {R4-R6,PC}       ;; return
    333          
    334          
    335          /*-----------------------------------------------------------------------------
    336          Function: AntAbortMessage
    337          
    338          Description:
    339          Kills the current message in progress with ANT and resets all of the pointers.
    340          Any existing received buffer data is lost.
    341          
    342          *** Warning: all interrupts are disabled, so this could impact system tick time ***
    343          
    344          Requires:
    345            - 
    346          
    347          Promises:
    348            - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    349              and Ant_u8AntNewRxMessages reset.
    350          */

   \                                 In section .text, align 2, keep-with-next
    351          static void AntAbortMessage(void)
    352          {
    353            __disable_interrupt();
   \                     AntAbortMessage: (+1)
   \   00000000   0xB672             CPSID    I
    354            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    355            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000014   0x6008             STR      R0,[R1, #+0]
    356            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    357            Ant_u8AntNewRxMessages = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    358            __enable_interrupt();
   \   00000028   0xB662             CPSIE    I
    359            
    360          } /* end AntAbortMessage() */
   \   0000002A   0x4770             BX       LR               ;; return
    361          
    362          
    363          /*-----------------------------------------------------------------------------
    364          Function: AdvanceAntRxBufferCurrentChar
    365          
    366          Description:
    367          Safely advances the Ant_pu8AntRxBufferCurrentChar within the circular buffer
    368          
    369          Requires:
    370            - No interrupt functions using Ant_pu8AntRxBufferCurrentChar are allowed to run
    371          
    372          Promises:
    373            - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    374          */

   \                                 In section .text, align 2, keep-with-next
    375          static void AdvanceAntRxBufferCurrentChar(void)
    376          {
    377            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    378            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    379            {
    380              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000024   0x6008             STR      R0,[R1, #+0]
    381            }
    382            
    383          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    384          
    385          
    386          /*-----------------------------------------------------------------------------/
    387          Function: AdvanceAntRxBufferUnreadMsgPointer
    388          
    389          Description:
    390          Increments the Rx buffer pointer and handles the wrap-around.
    391          
    392          Requires:
    393            - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    394          
    395          Promises:
    396            - Ant_pu8AntRxBufferUnreadMsg is pointing to the next char in the circular buffer
    397          */

   \                                 In section .text, align 2, keep-with-next
    398          static void AdvanceAntRxBufferUnreadMsgPointer()
    399          {
    400            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    401            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    402            {
    403              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    404            }
    405            
    406          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    407          
    408          
    409          /***********************************************************************************************************************
    410          @@@@@ ANT Interface-layer Functions
    411          ***********************************************************************************************************************/
    412            
    413          /*------------------------------------------------------------------------------
    414          Function: AntInitialize
    415          
    416          Description:
    417          Intialize the ANT system.  ANT device is reset and communication checked through
    418          a version request.  The main channel parameters are then set up to default values.
    419            
    420          Requires:
    421            - ANT_SPI peripheral is correctly configured
    422            - Debug system is initialized so debug messages can be sent to UART
    423          
    424          Promises:
    425            - G_stAntSetupData set to default ANT values
    426            - If all successful, G_u32SystemFlags.AntGood bit is set and ANT system is ready
    427            - Ant_pfnStateMachine = AntSM_Idle
    428          */

   \                                 In section .text, align 2, keep-with-next
    429          void AntInitialize(void)
    430          {
   \                     AntInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    431            u32 u32AntPortAPins, u32AntPortBPins;
    432          
    433            if(G_u32SystemFlags & _SYSTEM_STARTUP_NO_ANT)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0xD509             BPL.N    ??AntInitialize_0
    434            {
    435              DebugPrintf(G_au8AntMessageNoAnt);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000010   0x.... 0x....      BL       DebugPrintf
    436              Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19_4
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE0AE             B.N      ??AntInitialize_1
    437            }
    438            else
    439            {
    440              /* Give PIO control of ANT_RESET line */
    441              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \   00000020   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19_6  ;; 0x400e0e10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    442              
    443              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    444              DebugPrintf(G_au8AntMessageInit);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_7
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    445              G_sAntApplicationMsgList = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   00000038   0x6008             STR      R0,[R1, #+0]
    446              Ant_psDataOutgoingMsgList = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable19_9
   \   00000040   0x6008             STR      R0,[R1, #+0]
    447              
    448              /* Set default setup values in the AntSetupData struct */
    449              G_stAntSetupData.AntChannel          = ANT_CHANNEL_DEFAULT;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    450              G_stAntSetupData.AntChannelType      = ANT_CHANNEL_TYPE_DEFAULT;
   \   0000004A   0x2010             MOVS     R0,#+16
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000050   0x7048             STRB     R0,[R1, #+1]
    451              G_stAntSetupData.AntNetwork          = ANT_NETWORK_DEFAULT;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000058   0x7088             STRB     R0,[R1, #+2]
    452              G_stAntSetupData.AntSerialLo         = ANT_SERIAL_LO_DEFAULT;
   \   0000005A   0x20FF             MOVS     R0,#+255
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000060   0x70C8             STRB     R0,[R1, #+3]
    453              G_stAntSetupData.AntSerialHi         = ANT_SERIAL_HI_DEFAULT;
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000068   0x7108             STRB     R0,[R1, #+4]
    454              G_stAntSetupData.AntDeviceType       = ANT_DEVICE_TYPE_DEFAULT;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000070   0x7148             STRB     R0,[R1, #+5]
    455              G_stAntSetupData.AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000078   0x7188             STRB     R0,[R1, #+6]
    456              G_stAntSetupData.AntChannelPeriodLo  = ANT_CHANNEL_PERIOD_LO_DEFAULT;
   \   0000007A   0x20CD             MOVS     R0,#+205
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000080   0x71C8             STRB     R0,[R1, #+7]
    457              G_stAntSetupData.AntChannelPeriodHi  = ANT_CHANNEL_PERIOD_HI_DEFAULT;
   \   00000082   0x200C             MOVS     R0,#+12
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000088   0x7208             STRB     R0,[R1, #+8]
    458              G_stAntSetupData.AntFrequency        = ANT_FREQUENCY_DEFAULT;
   \   0000008A   0x2037             MOVS     R0,#+55
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000090   0x7248             STRB     R0,[R1, #+9]
    459              G_stAntSetupData.AntTxPower          = ANT_TX_POWER_DEFAULT;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000098   0x7288             STRB     R0,[R1, #+10]
    460              
    461              /* Configure the SSP resource to be used for the application */
    462              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    463              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable19_11  ;; 0x400e0e00
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000AA   0x6048             STR      R0,[R1, #+4]
    464              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \   000000AC   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000B4   0x6088             STR      R0,[R1, #+8]
    465              Ant_sSspConfig.BitOrder           = LSB_FIRST;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000BC   0x7308             STRB     R0,[R1, #+12]
    466              Ant_sSspConfig.SpiMode            = SPI_SLAVE_FLOW_CONTROL;
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000C4   0x7348             STRB     R0,[R1, #+13]
    467              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \   000000C6   0x.... 0x....      ADR.W    R0,AntTxFlowControlCallback
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000CE   0x6108             STR      R0,[R1, #+16]
    468              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \   000000D0   0x.... 0x....      ADR.W    R0,AntRxFlowControlCallback
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000D8   0x6148             STR      R0,[R1, #+20]
    469              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000E2   0x6188             STR      R0,[R1, #+24]
    470              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000EC   0x61C8             STR      R0,[R1, #+28]
    471              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \   000000EE   0xF44F 0x7080      MOV      R0,#+256
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable19_10
   \   000000F6   0x8408             STRH     R0,[R1, #+32]
    472          
    473              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable19_10
   \   000000FC   0x.... 0x....      BL       SspRequest
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable19_12
   \   00000104   0x6008             STR      R0,[R1, #+0]
    474              ANT_SSP_FLAGS = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000010C   0x6008             STR      R0,[R1, #+0]
    475              
    476              /* Reset ANT, activate SPI interface and get a test message */
    477              AntSyncSerialInitialize();
   \   0000010E   0x.... 0x....      BL       AntSyncSerialInitialize
    478              
    479              /* Report status out the debug port */
    480              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable19_13
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x06C0             LSLS     R0,R0,#+27
   \   0000011A   0xD50F             BPL.N    ??AntInitialize_2
    481              {
    482                DebugPrintf(G_au8AntMessageOk);
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable19_14
   \   00000120   0x.... 0x....      BL       DebugPrintf
    483                DebugPrintf(Ant_u8AntVersion);
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable19_15
   \   00000128   0x.... 0x....      BL       DebugPrintf
    484                DebugLineFeed();
   \   0000012C   0x.... 0x....      BL       DebugLineFeed
    485                Ant_pfnStateMachine = AntSM_Idle;
   \   00000130   0x.... 0x....      ADR.W    R0,AntSM_Idle
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000138   0x6008             STR      R0,[R1, #+0]
   \   0000013A   0xE020             B.N      ??AntInitialize_1
    486              }
    487              else
    488              {
    489                /* The ANT device is not responding -- it may be dead, or it may not yet
    490                be loaded with any firmware.  Regardless, float all of the interface lines so 
    491                that any programmer or other firmware will not be impacted by the Host MCU */
    492                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_2: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable19_16
   \   00000140   0x.... 0x....      BL       DebugPrintf
    493          
    494                /* Make sure all ANT pins are on the PIO controller */
    495                u32AntPortAPins = ANT_PIOA_PINS;
   \   00000144   0xF05F 0x7030      MOVS     R0,#+46137344
   \   00000148   0x0004             MOVS     R4,R0
    496                u32AntPortBPins = ANT_PIOB_PINS;
   \   0000014A   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   0000014E   0x0005             MOVS     R5,R0
    497                
    498                AT91C_BASE_PIOA->PIO_PDR = u32AntPortAPins;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable19_17  ;; 0x400e0c04
   \   00000154   0x6004             STR      R4,[R0, #+0]
    499                AT91C_BASE_PIOA->PIO_PER = u32AntPortAPins;
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable19_18  ;; 0x400e0c00
   \   0000015A   0x6004             STR      R4,[R0, #+0]
    500                AT91C_BASE_PIOB->PIO_PDR = u32AntPortBPins;
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable19_19  ;; 0x400e0e04
   \   00000160   0x6005             STR      R5,[R0, #+0]
    501                AT91C_BASE_PIOB->PIO_PER = u32AntPortBPins;
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable19_11  ;; 0x400e0e00
   \   00000166   0x6005             STR      R5,[R0, #+0]
    502          
    503                /* Disable all outputs (set to HiZ input) */
    504                AT91C_BASE_PIOA->PIO_ODR = u32AntPortAPins;
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable19_20  ;; 0x400e0c14
   \   0000016C   0x6004             STR      R4,[R0, #+0]
    505                AT91C_BASE_PIOB->PIO_ODR = u32AntPortBPins;
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable19_21  ;; 0x400e0e14
   \   00000172   0x6005             STR      R5,[R0, #+0]
    506                
    507                Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000174   0x.... 0x....      ADR.W    R0,AntSM_NoResponse
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000017C   0x6008             STR      R0,[R1, #+0]
    508              }
    509            }
    510          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \   0000017E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    511          
    512          
    513          /*----------------------------------------------------------------------------------------------------------------------
    514          Function AntRunActiveState()
    515          
    516          Description:
    517          Selects and runs one iteration of the current state in the state machine.
    518          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    519          may take 1ms / n to execute.
    520          
    521          Requires:
    522            - State machine function pointer points at current state
    523          
    524          Promises:
    525            - Calls the function to pointed by the state machine function pointer
    526          */

   \                                 In section .text, align 2, keep-with-next
    527          void AntRunActiveState(void)
    528          {
   \                     AntRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    529            Ant_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    530          
    531          } /* end AntRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    532          
    533          
    534          /*-----------------------------------------------------------------------------
    535          Function: AntTxMessage
    536          
    537          Description:
    538          Send a message from the Host to the ANT device.  To do this, we must tell ANT that we have
    539          a message to send by asserting MRDY, wait for ANT to acknowlege with SEN, then read a byte from
    540          ANT to confirm the transmission can proceed.  If ANT happens to wants to send a message at the
    541          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend and go read the 
    542          incoming message first.  The process would restart after that.
    543          
    544          Once ANT confirms that the Host may transmit, the message to transmit is queued data is sent byte-by-byte with SRDY used for flow
    545          control after each byte.  Due to the speed of the chip-to-chip communications, even the longest ANT message
    546          should be able to send in less than 500us, so it is safe to run this function completely in one main loop
    547          iteration (and retry or additional messages should wait until the following cycle).  
    548          
    549          Adapted from Dynastream Innovations Inc reference design, BitSyncSerial.c.
    550          
    551          Requires:
    552            - pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    553              is the length byte (since ANT sends the SYNC byte) and the last byte is
    554              the checksum.
    555          
    556          Promises:
    557            - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    558            - Returns FALSE if the transfer couldn't start or if receive message interrupted
    559              (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    560            - MRDY is deasserted
    561          */

   \                                 In section .text, align 2, keep-with-next
    562          bool AntTxMessage(u8 *pu8AntTxMessage_)
    563          {
   \                     AntTxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   \   00000004   0x0004             MOVS     R4,R0
    564            u8 u8Byte;
    565            u32 u32Length;
    566            u32 u32TimeOut = G_u32SystemTime1s;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19_22
   \   0000000A   0x6807             LDR      R7,[R0, #+0]
    567            u8 au8TxErrorMsg[] = "AntTx: msg already in progress\n\r";
   \   0000000C   0xA810             ADD      R0,SP,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19_23
   \   00000012   0x2221             MOVS     R2,#+33
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
    568            u8 au8TxTimeoutMsg[] = "AntTx: SEN timeout\n\r";
   \   00000018   0xA80A             ADD      R0,SP,#+40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable19_24
   \   0000001E   0x2215             MOVS     R2,#+21
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
    569            u8 au8TxNoTokenMsg[] = "AntTx: No token\n\r";
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable19_25
   \   0000002A   0x2212             MOVS     R2,#+18
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    570            u8 au8TxNoSyncMsg[] = "AntTx: No SYNC\n\r";
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable19_26
   \   00000036   0x2211             MOVS     R2,#+17
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    571          
    572            /* Check G_u32AntFlags first */
    573            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x6F40      TST      R0,#0xC000000
   \   00000046   0xD004             BEQ.N    ??AntTxMessage_0
    574            {
    575              DebugPrintf(au8TxErrorMsg);
   \   00000048   0xA810             ADD      R0,SP,#+64
   \   0000004A   0x.... 0x....      BL       DebugPrintf
    576              return FALSE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE0A8             B.N      ??AntTxMessage_1
    577            }
    578            
    579            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    580            Ant_u32RxTimeoutCounter = 0;
   \                     ??AntTxMessage_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000058   0x6008             STR      R0,[R1, #+0]
    581            SYNC_MRDY_ASSERT();                          
   \   0000005A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   00000062   0x6008             STR      R0,[R1, #+0]
    582          
    583            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    584            while ( !IS_SEN_ASSERTED() &&
    585                    (Ant_u32RxTimeoutCounter < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD40E             BMI.N    ??AntTxMessage_3
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xf4240
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD207             BCS.N    ??AntTxMessage_3
    586            {
    587              Ant_u32RxTimeoutCounter++;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE7EB             B.N      ??AntTxMessage_2
    588            }
    589            
    590            /* If we timed out, then clear MRDY and exit */
    591            if(Ant_u32RxTimeoutCounter > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0xf4241
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD309             BCC.N    ??AntTxMessage_4
    592            {
    593             SYNC_MRDY_DEASSERT();                          
   \   0000009A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    594             DebugPrintf(au8TxTimeoutMsg);
   \   000000A4   0xA80A             ADD      R0,SP,#+40
   \   000000A6   0x.... 0x....      BL       DebugPrintf
    595             return(FALSE);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE07A             B.N      ??AntTxMessage_1
    596            }
    597            
    598            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    599            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     ??AntTxMessage_4: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_5: (+1)
   \   000000B0   0xF5B0 0x7F96      CMP      R0,#+300
   \   000000B4   0xD201             BCS.N    ??AntTxMessage_6
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0xE7FA             B.N      ??AntTxMessage_5
    600            SYNC_SRDY_ASSERT();
   \                     ??AntTxMessage_6: (+1)
   \   000000BA   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   000000C2   0x6008             STR      R0,[R1, #+0]
    601            SYNC_SRDY_DEASSERT();    
   \   000000C4   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    602          
    603            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    604            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    605                   (Ant_u32RxTimeoutCounter < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_7: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x0700             LSLS     R0,R0,#+28
   \   000000D6   0xD40E             BMI.N    ??AntTxMessage_8
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xf4240
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xD207             BCS.N    ??AntTxMessage_8
    606            {
    607              Ant_u32RxTimeoutCounter++;
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000F2   0x6008             STR      R0,[R1, #+0]
   \   000000F4   0xE7EB             B.N      ??AntTxMessage_7
    608            }
    609          
    610            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_8: (+1)
   \   000000F6   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    611          
    612            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    613            will attempt to read a message but fail and eventually abort. */
    614            if(Ant_u32RxTimeoutCounter > ANT_ACTIVITY_TIME_COUNT)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0xf4241
   \   0000010A   0x4288             CMP      R0,R1
   \   0000010C   0xD304             BCC.N    ??AntTxMessage_9
    615            {
    616             DebugPrintf(au8TxTimeoutMsg);
   \   0000010E   0xA80A             ADD      R0,SP,#+40
   \   00000110   0x.... 0x....      BL       DebugPrintf
    617             return(FALSE);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xE045             B.N      ??AntTxMessage_1
    618            }
    619                    
    620            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    621            Rx callback.  The callback does NOT toggle SRDY at this time because the CS_ASSERTED flag will 
    622            still be set indicating that this is the first byte.  We must look at this byte to determine if
    623            ANT initiated this particular communication and is telling us that a message is coming in, or if 
    624            we initiated the communication and ANT is allowing us to transmit. */
    625          
    626            /* Read the byte - don't advance the pointer */
    627            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_9: (+1)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x7800             LDRB     R0,[R0, #+0]
   \   00000120   0x0005             MOVS     R5,R0
    628          
    629            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    630            if (u8Byte == MESG_TX_SYNC)                     
   \   00000122   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000124   0x2DA4             CMP      R5,#+164
   \   00000126   0xD109             BNE.N    ??AntTxMessage_10
    631            {
    632              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000136   0x6008             STR      R0,[R1, #+0]
    633              return(FALSE);
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE033             B.N      ??AntTxMessage_1
    634            }
    635          
    636            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    637            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_10: (+1)
   \   0000013C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    638            AdvanceAntRxBufferUnreadMsgPointer();
   \   00000140   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    639          
    640            /* Clear the two status flags and process the byte */
    641            ANT_SSP_FLAGS &= ~(_SSP_RX_COMPLETE | _SSP_CS_ASSERTED);
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0xF030 0x0009      BICS     R0,R0,#0x9
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000152   0x6008             STR      R0,[R1, #+0]
    642            
    643            /* If the byte is RX_SYNC, then proceed to send the message */
    644            if (u8Byte == MESG_RX_SYNC)                     
   \   00000154   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000156   0x2DA5             CMP      R5,#+165
   \   00000158   0xD120             BNE.N    ??AntTxMessage_11
    645            {
    646              /* Flag that a transmit is in progress */
    647              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000015E   0x6800             LDR      R0,[R0, #+0]
   \   00000160   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000168   0x6008             STR      R0,[R1, #+0]
    648              
    649              /* Read the message length and add three for the length, message ID and checksum */
    650              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \   0000016A   0x7820             LDRB     R0,[R4, #+0]
   \   0000016C   0x1CC0             ADDS     R0,R0,#+3
   \   0000016E   0x0006             MOVS     R6,R0
    651              
    652              /* Queue the message to the peripheral and capture the token */ 
    653              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \   00000170   0x0022             MOVS     R2,R4
   \   00000172   0x0031             MOVS     R1,R6
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable19_12
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0x.... 0x....      BL       SspWriteData
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable19_27
   \   00000182   0x6008             STR      R0,[R1, #+0]
    654          
    655              /* Return TRUE only if we received a message token indicating the message has been queued */
    656              if(Ant_u32CurrentTxMessageToken != 0)
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable19_27
   \   00000188   0x6800             LDR      R0,[R0, #+0]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD001             BEQ.N    ??AntTxMessage_12
    657              {
    658                return(TRUE);
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0xE008             B.N      ??AntTxMessage_1
    659              }
    660              else
    661              {
    662                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_12: (+1)
   \   00000192   0xA805             ADD      R0,SP,#+20
   \   00000194   0x.... 0x....      BL       DebugPrintf
    663                return(FALSE);
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0xE003             B.N      ??AntTxMessage_1
    664              }
    665            }
    666          
    667            /* If we get here, not a sync byte, so return */
    668            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_11: (+1)
   \   0000019C   0xA800             ADD      R0,SP,#+0
   \   0000019E   0x.... 0x....      BL       DebugPrintf
    669            return(FALSE);
   \   000001A2   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \   000001A4   0xB019             ADD      SP,SP,#+100
   \   000001A6   0xBDF0             POP      {R4-R7,PC}       ;; return
    670          
    671          } /* end AntTxMessage() */
    672          
    673          
    674          /*------------------------------------------------------------------------------
    675          Function: AntExpectResponse
    676          
    677          Description:
    678          Waits a specified amount of time for a particular message to arrive from ANT in 
    679          response to a message sent to ANT.  
    680          
    681          *** This function violates the 1ms system rule, so should only be used during initialization. ***
    682            
    683          Requires:
    684            - u8ExpectedMessageID_ is the ID of a message to which a response is expected
    685            - u32TimeoutMS_ is the maximum value in ms to wait for the response 
    686            - A message had been sent to ANT to which a response should be coming in
    687            - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    688              transmitted messages.
    689            - SSP task should be in manual mode so it is busy sending the Tx message to which
    690              this function will wait for the ANT response.
    691          
    692          Promises:
    693            - Returns 0 if the message is received and was successful
    694            - Returns 1 if a response is never received or if the response indicates the
    695              message was not successful.
    696          */

   \                                 In section .text, align 2, keep-with-next
    697          u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    698          {
   \                     AntExpectResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    699            bool bTimeout = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
    700            u8 u8ReturnValue = 1;
   \   0000000A   0x2701             MOVS     R7,#+1
    701            u32 u32StartTime = G_u32SystemTime1s;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_22
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x9000             STR      R0,[SP, #+0]
    702            u8 au8AntExpectMsgFail[] = "\r\nANT expected msg fail\n\r";
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable19_28
   \   0000001A   0x221A             MOVS     R2,#+26
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    703          
    704            /* Wait for current message to send */
    705            u32StartTime = G_u32SystemTime1ms;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x9000             STR      R0,[SP, #+0]
    706            while( QueryMessageStatus(Ant_u32CurrentTxMessageToken) != COMPLETE && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19_27
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       QueryMessageStatus
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD009             BEQ.N    ??AntExpectResponse_1
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD106             BNE.N    ??AntExpectResponse_1
    707            {
    708              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   0000003C   0xF241 0x3188      MOVW     R1,#+5000
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       IsTimeUp
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0xE7EE             B.N      ??AntExpectResponse_0
    709            }
    710          
    711            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2E00             CMP      R6,#+0
   \   0000004E   0xD120             BNE.N    ??AntExpectResponse_2
    712            {
    713              /* Done with this message token, so it can be cleared */
    714              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    715              AntDeQueueOutgoingMessage();
   \   00000060   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    716              Ant_u32CurrentTxMessageToken = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable19_27
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    717              
    718              /* Wait for SEN */
    719              u32StartTime = G_u32SystemTime1ms;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x9000             STR      R0,[SP, #+0]
    720              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x07C0             LSLS     R0,R0,#+31
   \   0000007C   0xD409             BMI.N    ??AntExpectResponse_2
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD106             BNE.N    ??AntExpectResponse_2
    721              {
    722                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000084   0xF241 0x3188      MOVW     R1,#+5000
   \   00000088   0xA800             ADD      R0,SP,#+0
   \   0000008A   0x.... 0x....      BL       IsTimeUp
   \   0000008E   0x0006             MOVS     R6,R0
   \   00000090   0xE7F0             B.N      ??AntExpectResponse_3
    723              }
    724            }
    725            
    726            /* If no timeout then read the incoming message */
    727            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x2E00             CMP      R6,#+0
   \   00000096   0xD11B             BNE.N    ??AntExpectResponse_4
    728            {
    729              AntRxMessage();
   \   00000098   0x.... 0x....      BL       AntRxMessage
    730          
    731              /* If there is a new message in the receive buffer, then check that it is a response to the expected
    732              message and that the response is no error */
    733              if(Ant_u8AntNewRxMessages)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD014             BEQ.N    ??AntExpectResponse_4
    734              {
    735                /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
    736                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
    737                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
    738                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
    739                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x7880             LDRB     R0,[R0, #+2]
   \   000000AE   0x2840             CMP      R0,#+64
   \   000000B0   0xD10E             BNE.N    ??AntExpectResponse_4
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x7900             LDRB     R0,[R0, #+4]
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x42A0             CMP      R0,R4
   \   000000BE   0xD107             BNE.N    ??AntExpectResponse_4
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x7940             LDRB     R0,[R0, #+5]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD101             BNE.N    ??AntExpectResponse_4
    740                {
    741                  u8ReturnValue = 0;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x0007             MOVS     R7,R0
    742                }
    743              }
    744            }
    745            
    746            /* Process any message in the RxBuffer and return the result value */
    747            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \   000000D0   0x.... 0x....      BL       AntProcessMessage
    748            
    749            if( bTimeout )
   \   000000D4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D6   0x2E00             CMP      R6,#+0
   \   000000D8   0xD002             BEQ.N    ??AntExpectResponse_5
    750            {
    751              DebugPrintf(au8AntExpectMsgFail);
   \   000000DA   0xA801             ADD      R0,SP,#+4
   \   000000DC   0x.... 0x....      BL       DebugPrintf
    752              /* !!!! What clean-up should be done here?  Reset ANT and restart init? */
    753            }
    754          
    755            /* Update Rx flag regardless and return */
    756            G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntExpectResponse_5: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   000000EE   0x6008             STR      R0,[R1, #+0]
    757            return(u8ReturnValue);
   \   000000F0   0x0038             MOVS     R0,R7
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0xB009             ADD      SP,SP,#+36
   \   000000F6   0xBDF0             POP      {R4-R7,PC}       ;; return
    758          
    759          } /* end AntExpectResponse */
    760          
    761          
    762          /*-----------------------------------------------------------------------------
    763          Function: AntTxFlowControlCallback
    764          
    765          Description:
    766          Callback function to toggle flow control during transmission.  The peripheral task
    767          sending the message must invoke this function after each byte.  
    768          
    769          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    770          
    771          Requires:
    772            - 
    773          
    774          Promises:
    775            - SRDY is toggled
    776            - Ant_u32TxByteCounter incremented
    777          */
    778          

   \                                 In section .text, align 4, keep-with-next
    779          void AntTxFlowControlCallback(void)
    780          {
    781            /* Count the byte and toggle flow control lines */
    782            Ant_u32TxByteCounter++;
   \                     AntTxFlowControlCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19_30
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable19_30
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    783          
    784            /* Provide a short delay before toggling SRDY */
    785            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??AntTxFlowControlCallback_0: (+1)
   \   00000010   0xF5B0 0x7F96      CMP      R0,#+300
   \   00000014   0xD201             BCS.N    ??AntTxFlowControlCallback_1
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7FA             B.N      ??AntTxFlowControlCallback_0
    786            SYNC_SRDY_ASSERT();
   \                     ??AntTxFlowControlCallback_1: (+1)
   \   0000001A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   00000022   0x6008             STR      R0,[R1, #+0]
    787            SYNC_SRDY_DEASSERT();
   \   00000024   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    788          
    789          } /* end AntTxFlowControlCallback() */
   \   0000002E   0x4770             BX       LR               ;; return
    790          
    791          
    792          /*-----------------------------------------------------------------------------
    793          Function: AntRxFlowControlCallback
    794          
    795          Description:
    796          Callback function to toggle flow control during reception.  The peripheral task
    797          receiving the message must invoke this function after each byte.  
    798          
    799          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    800          
    801          Requires:
    802            - ISRs are off already since this is totally not re-entrant
    803            - A received byte was just written to the Rx buffer
    804            - _SSP_CS_ASSERTED in correct state: should be set on first byte, but application should 
    805              clear it for all subsequent bytes so flow control is handled entirely by this function
    806          
    807          Promises:
    808            - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
    809            - SRDY is toggled if _SSP_CS_ASSERTED is clear
    810            - Ant_u32RxByteCounter incremented
    811          */

   \                                 In section .text, align 4, keep-with-next
    812          void AntRxFlowControlCallback(void)
    813          {
    814            /* Check if we are receiving or transmitting: only want to capture received
    815            bytes when we are receiving (don't care about dummy bytes) */
    816          #if 0
    817            if( G_u32AntFlags & _ANT_FLAGS_TX_IN_PROGRESS )
    818            {
    819              Ant_DebugUnexpectedRxByte++;
    820            }
    821          #endif
    822            
    823            /* Count the byte and safely advance the receive buffer pointer */
    824            Ant_u32RxByteCounter++;
   \                     AntRxFlowControlCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    825            Ant_pu8AntRxBufferNextChar++;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    826            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD104             BNE.N    ??AntRxFlowControlCallback_0
    827            {
    828              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_31
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   00000032   0x6008             STR      R0,[R1, #+0]
    829            }
    830            
    831          #if 0
    832            else
    833            {
    834              /* Should not be logging a byte if not receiving */
    835              Ant_DebugUnexpectedRxByte++;
    836            }
    837          #endif
    838            
    839            /* Provide a short delay before toggling SRDY */
    840            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     ??AntRxFlowControlCallback_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??AntRxFlowControlCallback_1: (+1)
   \   00000036   0xF5B0 0x7F96      CMP      R0,#+300
   \   0000003A   0xD201             BCS.N    ??AntRxFlowControlCallback_2
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0xE7FA             B.N      ??AntRxFlowControlCallback_1
    841            
    842            /* Toggle the flow control lines if _SSP_CS_ASSERTED is clear */
    843            if( !(ANT_SSP_FLAGS & _SSP_CS_ASSERTED) )
   \                     ??AntRxFlowControlCallback_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x07C0             LSLS     R0,R0,#+31
   \   00000048   0xD409             BMI.N    ??AntRxFlowControlCallback_3
    844            {
    845              SYNC_SRDY_ASSERT();
   \   0000004A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x400e0e34
   \   00000052   0x6008             STR      R0,[R1, #+0]
    846              SYNC_SRDY_DEASSERT();
   \   00000054   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x400e0e30
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    847            }
    848            
    849          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_3: (+1)
   \   0000005E   0x4770             BX       LR               ;; return
    850          
    851          
    852          /*------------------------------------------------------------------------------
    853          Function: AntCalculateTxChecksum
    854          
    855          Description:
    856          Calculates and returns the checksum for a Host > ANT message.
    857          
    858          Requires:
    859            - pu8Message_ points to the message to transmit
    860            - the message to transmit is a complete ANT message except the SYNC byte (starts with length byte)
    861          
    862          Promises:
    863            - Finds ANT checksum for the message and returns it
    864          */

   \                                 In section .text, align 2, keep-with-next
    865          u8 AntCalculateTxChecksum(u8* pu8Message_)
    866          {
   \                     AntCalculateTxChecksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    867            u8 u8Size = *pu8Message_ + 2;
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x1C82             ADDS     R2,R0,#+2
    868            u8 u8Checksum = MESG_RX_SYNC;
   \   00000008   0x20A5             MOVS     R0,#+165
    869            
    870            for(u8 i = 0; i < u8Size; i++)
   \   0000000A   0x2300             MOVS     R3,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD204             BCS.N    ??AntCalculateTxChecksum_1
    871            {
    872              u8Checksum ^= *pu8Message_;
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x4060             EORS     R0,R4,R0
    873              pu8Message_++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
    874            }
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F6             B.N      ??AntCalculateTxChecksum_0
    875            
    876            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    877            
    878          } /* end AntCalculateTxChecksum() */
    879          
    880          
    881          /*-----------------------------------------------------------------------------/
    882          Function: AntQueueOutgoingMessage
    883          
    884          Description:
    885          Creates a new ANT message structure and adds it into Ant_psDataOutgoingMsgList.
    886          If the list is full, the message is not added.
    887          
    888          Requires:
    889            - pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
    890            - Enough space is available on the heap
    891          
    892          Promises:
    893            - A new list item in the outgoing message linked list is created and inserted at the end
    894              of the list as long as there is enough room.
    895            - Returns TRUE if the entry is added successfully.
    896            - Returns FALSE on error.
    897          */

   \                                 In section .text, align 2, keep-with-next
    898          bool AntQueueOutgoingMessage(u8 *pu8Message_)
    899          {
   \                     AntQueueOutgoingMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
    900            u8 u8Length;
    901            u8 u8MessageCount;
    902            AntOutgoingMessageListType *psNewDataMessage;
    903            AntOutgoingMessageListType *psListParser;
    904            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable19_32
   \   0000000E   0x2228             MOVS     R2,#+40
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    905            
    906            Ant_DebugQueuedDataMessages++;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19_33
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19_33
   \   00000020   0x6008             STR      R0,[R1, #+0]
    907          
    908            /* Allocate space for the new message - always do maximum message size */
    909            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \   00000022   0x201C             MOVS     R0,#+28
   \   00000024   0x.... 0x....      BL       malloc
   \   00000028   0x0007             MOVS     R7,R0
    910            if (psNewDataMessage == NULL)
   \   0000002A   0x2F00             CMP      R7,#+0
   \   0000002C   0xD104             BNE.N    ??AntQueueOutgoingMessage_0
    911            {
    912              DebugPrintf(au8AddMessageFailMsg);
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       DebugPrintf
    913              return(FALSE);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE03A             B.N      ??AntQueueOutgoingMessage_1
    914            }
    915            
    916            /* Fill in all the fields of the newly allocated message structure */
    917            u8Length = *pu8Message_ + 3;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x1CC0             ADDS     R0,R0,#+3
   \   0000003C   0x0005             MOVS     R5,R0
    918            for(u8 i = 0; i < u8Length; i++)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD206             BCS.N    ??AntQueueOutgoingMessage_3
    919            {
    920              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x5D01             LDRB     R1,[R0, R4]
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x19C2             ADDS     R2,R0,R7
   \   00000050   0x7111             STRB     R1,[R2, #+4]
    921            }
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xE7F4             B.N      ??AntQueueOutgoingMessage_2
    922            
    923            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x6038             STR      R0,[R7, #+0]
    924            psNewDataMessage->psNextMessage = NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x61B8             STR      R0,[R7, #+24]
    925          
    926            /* Insert into an empty list */
    927            if(Ant_psDataOutgoingMsgList == NULL)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable19_9
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD103             BNE.N    ??AntQueueOutgoingMessage_4
    928            {
    929              Ant_psDataOutgoingMsgList = psNewDataMessage;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable19_9
   \   00000070   0x6007             STR      R7,[R0, #+0]
   \   00000072   0xE01B             B.N      ??AntQueueOutgoingMessage_5
    930            }
    931          
    932            /* Otherwise traverse the list to find the end where the new message will be inserted */
    933            else
    934            {
    935              psListParser = Ant_psDataOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable19_9
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x4680             MOV      R8,R0
    936              u8MessageCount = 1;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x0006             MOVS     R6,R0
    937              while( (psListParser->psNextMessage != NULL) && 
    938                     (u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE) )
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \   00000080   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD006             BEQ.N    ??AntQueueOutgoingMessage_7
   \   00000088   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008A   0x2E20             CMP      R6,#+32
   \   0000008C   0xD203             BCS.N    ??AntQueueOutgoingMessage_7
    939              {
    940                psListParser = psListParser->psNextMessage;
   \   0000008E   0xF8D8 0x8018      LDR      R8,[R8, #+24]
    941                u8MessageCount++;
   \   00000092   0x1C76             ADDS     R6,R6,#+1
   \   00000094   0xE7F4             B.N      ??AntQueueOutgoingMessage_6
    942              }
    943              
    944              /* Handle a full list */
    945              if(u8MessageCount != ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \   00000096   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000098   0x2E20             CMP      R6,#+32
   \   0000009A   0xD002             BEQ.N    ??AntQueueOutgoingMessage_8
    946              {
    947                /* Insert the new message at the end of the list */
    948                psListParser->psNextMessage = psNewDataMessage;
   \   0000009C   0xF8C8 0x7018      STR      R7,[R8, #+24]
   \   000000A0   0xE004             B.N      ??AntQueueOutgoingMessage_5
    949              }
    950              else
    951              {
    952                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \   000000A2   0xA800             ADD      R0,SP,#+0
   \   000000A4   0x.... 0x....      BL       DebugPrintf
    953                return(FALSE);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE000             B.N      ??AntQueueOutgoingMessage_1
    954              }
    955            }
    956              
    957            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \   000000AC   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \   000000AE   0xB00A             ADD      SP,SP,#+40
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    958            
    959          } /* end AntQueueOutgoingMessage() */
    960          
    961          
    962          /*-----------------------------------------------------------------------------/
    963          Function: AntDeQueueApplicationMessage
    964          
    965          Description:
    966          Releases the first message in G_sAntApplicationMsgList 
    967          
    968          Requires:
    969            - G_sAntApplicationMsgList points to the start of the list which is the entry to remove
    970          
    971          Promises:
    972            - G_sAntApplicationMsgList = G_sAntApplicationMsgList.
    973          */

   \                                 In section .text, align 2, keep-with-next
    974          void AntDeQueueApplicationMessage(void)
    975          {
   \                     AntDeQueueApplicationMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    976            AntApplicationMsgListType *psMessageToKill;
    977            
    978            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00D             BEQ.N    ??AntDeQueueApplicationMessage_0
    979            {
    980              psMessageToKill = G_sAntApplicationMsgList;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0004             MOVS     R4,R0
    981              G_sAntApplicationMsgList = G_sAntApplicationMsgList->psNextMessage;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6900             LDR      R0,[R0, #+16]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   00000020   0x6008             STR      R0,[R1, #+0]
    982          
    983              /* The doomed message is properly disconnected, so kill it */
    984              free(psMessageToKill);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       free
    985            }
    986            
    987          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    988          
    989          
    990          /* ANT private Interface-layer Functions */
    991          
    992                                              
    993          /*------------------------------------------------------------------------------
    994          Function: AntProcessMessage
    995          
    996          Description:
    997          Reads the lastest received Ant message and updates system information accordingly. 
    998            
    999          Requires:
   1000            - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1001            - GGpu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1002          
   1003          Promises:
   1004            - Returns 1 if Ant_u8AntNewRxMessages == 0
   1005            - Otherwise, returns 0 and:
   1006              - Ant_u8AntNewRxMessages--
   1007              - GGpu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1008              - System flags are updated
   1009          */

   \                                 In section .text, align 2, keep-with-next
   1010          static u8 AntProcessMessage(void)
   1011          {
   \                     AntProcessMessage: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1012            u8 u8MessageLength;
   1013            u8 au8MessageCopy[MESG_MAX_SIZE];
   1014            
   1015             /* Exit immediately if there are no messages in the RxBuffer */
   1016          	if (!Ant_u8AntNewRxMessages)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??AntProcessMessage_0
   1017              return(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE11C             B.N      ??AntProcessMessage_1
   1018            
   1019            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_34
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable19_34
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1020            
   1021            /* Otherwise decrement counter, and get a copy of the message (necessary since the rx buffer is circular)
   1022            and we want to index the various bytes using the ANT byte definitions. */  
   1023            Ant_u8AntNewRxMessages--;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1024            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000002E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1025            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0004             MOVS     R4,R0
   1026            
   1027            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1028            if(u8MessageLength > MESG_MAX_SIZE)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C12             CMP      R4,#+18
   \   00000040   0xDB01             BLT.N    ??AntProcessMessage_2
   1029            {
   1030              return(1);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE102             B.N      ??AntProcessMessage_1
   1031            }
   1032            
   1033            for(u8 i = 0; i < (u8)(u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
   \                     ??AntProcessMessage_3: (+1)
   \   00000048   0x1CE0             ADDS     R0,R4,#+3
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD20A             BCS.N    ??AntProcessMessage_4
   1034            {
   1035              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x5468             STRB     R0,[R5, R1]
   1036              AdvanceAntRxBufferUnreadMsgPointer();
   \   00000060   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1037            }
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \   00000066   0xE7EF             B.N      ??AntProcessMessage_3
   1038            /* Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1039            
   1040            /* Decide what to do based on the Message ID */
   1041            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \                     ??AntProcessMessage_4: (+1)
   \   00000068   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006C   0x283E             CMP      R0,#+62
   \   0000006E   0xF000 0x80CB      BEQ.W    ??AntProcessMessage_5
   \   00000072   0x2840             CMP      R0,#+64
   \   00000074   0xD00C             BEQ.N    ??AntProcessMessage_6
   \   00000076   0x284E             CMP      R0,#+78
   \   00000078   0xF000 0x80B8      BEQ.W    ??AntProcessMessage_7
   \   0000007C   0x284F             CMP      R0,#+79
   \   0000007E   0xF000 0x80A8      BEQ.W    ??AntProcessMessage_8
   \   00000082   0x2852             CMP      R0,#+82
   \   00000084   0xF000 0x80BF      BEQ.W    ??AntProcessMessage_9
   \   00000088   0x286F             CMP      R0,#+111
   \   0000008A   0xF000 0x80D1      BEQ.W    ??AntProcessMessage_10
   \   0000008E   0xE0D6             B.N      ??AntProcessMessage_11
   1042            {
   1043              case MESG_RESPONSE_EVENT_ID:
   1044              { 
   1045                /* Channel Message received: it is a Channel Response or Channel Event */
   1046                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \   00000090   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD040             BEQ.N    ??AntProcessMessage_12
   1047                {
   1048                  /* We have a Channel Response: parse it out based on the message ID to which the response applies */
   1049                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \   00000098   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000009C   0x2841             CMP      R0,#+65
   \   0000009E   0xD01D             BEQ.N    ??AntProcessMessage_13
   \   000000A0   0x2842             CMP      R0,#+66
   \   000000A2   0xD016             BEQ.N    ??AntProcessMessage_14
   \   000000A4   0x284B             CMP      R0,#+75
   \   000000A6   0xD002             BEQ.N    ??AntProcessMessage_15
   \   000000A8   0x284C             CMP      R0,#+76
   \   000000AA   0xD00D             BEQ.N    ??AntProcessMessage_16
   \   000000AC   0xE01B             B.N      ??AntProcessMessage_17
   1050                  {
   1051                    case MESG_OPEN_CHANNEL_ID:
   1052                      DebugPrintf(G_au8AntMessageOpen);
   \                     ??AntProcessMessage_15: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable19_35
   \   000000B2   0x.... 0x....      BL       DebugPrintf
   1053                      G_u32AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   1054                      break;
   \   000000C6   0xE012             B.N      ??AntProcessMessage_18
   1055          
   1056                    case MESG_CLOSE_CHANNEL_ID:
   1057                      DebugPrintf(G_au8AntMessageClose);
   \                     ??AntProcessMessage_16: (+1)
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable19_36
   \   000000CC   0x.... 0x....      BL       DebugPrintf
   1058                      break;
   \   000000D0   0xE00D             B.N      ??AntProcessMessage_18
   1059          
   1060                    case MESG_ASSIGN_CHANNEL_ID:
   1061                      DebugPrintf(G_au8AntMessageAssign);
   \                     ??AntProcessMessage_14: (+1)
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable19_37
   \   000000D6   0x.... 0x....      BL       DebugPrintf
   1062                      break;
   \   000000DA   0xE008             B.N      ??AntProcessMessage_18
   1063          
   1064                    case MESG_UNASSIGN_CHANNEL_ID:
   1065                      DebugPrintf(G_au8AntMessageUnassign);
   \                     ??AntProcessMessage_13: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable19_38
   \   000000E0   0x.... 0x....      BL       DebugPrintf
   1066                      break;
   \   000000E4   0xE003             B.N      ??AntProcessMessage_18
   1067           
   1068                    default:
   1069                      DebugPrintf(G_au8AntMessageUnhandled);
   \                     ??AntProcessMessage_17: (+1)
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable19_39
   \   000000EA   0x.... 0x....      BL       DebugPrintf
   1070                      break;
   1071                  } /* end switch */
   1072                  
   1073                  /* All messages print an "ok" or "fail" */
   1074                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_18: (+1)
   \   000000EE   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD104             BNE.N    ??AntProcessMessage_19
   1075                  {
   1076                    DebugPrintf(G_au8AntMessageOk);
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable19_14
   \   000000FA   0x.... 0x....      BL       DebugPrintf
   \   000000FE   0xE067             B.N      ??AntProcessMessage_20
   1077                  }
   1078                  else
   1079                  {
   1080                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_19: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable19_40
   \   00000104   0x.... 0x....      BL       DebugPrintf
   1081                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   00000116   0x6008             STR      R0,[R1, #+0]
   \   00000118   0xE05A             B.N      ??AntProcessMessage_20
   1082                  }
   1083          
   1084                }
   1085                else /* The message is a Channel Event, so the Event Code must be parsed out */
   1086                { 
   1087                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_12: (+1)
   \   0000011A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD00A             BEQ.N    ??AntProcessMessage_21
   \   00000122   0x2802             CMP      R0,#+2
   \   00000124   0xD009             BEQ.N    ??AntProcessMessage_22
   \   00000126   0x2803             CMP      R0,#+3
   \   00000128   0xD02A             BEQ.N    ??AntProcessMessage_23
   \   0000012A   0x2805             CMP      R0,#+5
   \   0000012C   0xD030             BEQ.N    ??AntProcessMessage_24
   \   0000012E   0x2806             CMP      R0,#+6
   \   00000130   0xD03A             BEQ.N    ??AntProcessMessage_25
   \   00000132   0x2807             CMP      R0,#+7
   \   00000134   0xD03C             BEQ.N    ??AntProcessMessage_26
   \   00000136   0xE044             B.N      ??AntProcessMessage_27
   1088                  {
   1089                    case RESPONSE_NO_ERROR: 
   1090                    {
   1091                      break;
   \                     ??AntProcessMessage_21: (+1)
   \   00000138   0xE04A             B.N      ??AntProcessMessage_20
   1092                    }
   1093          
   1094                    case EVENT_RX_FAIL: /* slave did not receive a message when expected */
   1095                    {
   1096                      /* The slave missed a message it was expecting: communicate this to the
   1097                      application in case it matters. Could also queue a debug message here. */
   1098                      if(++Ant_u8SlaveMissedMessageLow == 0)
   \                     ??AntProcessMessage_22: (+1)
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable19_41
   \   0000013E   0x7800             LDRB     R0,[R0, #+0]
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable19_41
   \   00000146   0x7008             STRB     R0,[R1, #+0]
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable19_41
   \   0000014C   0x7800             LDRB     R0,[R0, #+0]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD112             BNE.N    ??AntProcessMessage_28
   1099                      {
   1100                        if(++Ant_u8SlaveMissedMessageMid == 0)
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable19_42
   \   00000156   0x7800             LDRB     R0,[R0, #+0]
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable19_42
   \   0000015E   0x7008             STRB     R0,[R1, #+0]
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable19_42
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD106             BNE.N    ??AntProcessMessage_28
   1101                        {
   1102                          ++Ant_u8SlaveMissedMessageHigh;
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable19_43
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x1C40             ADDS     R0,R0,#+1
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable19_43
   \   00000176   0x7008             STRB     R0,[R1, #+0]
   1103                        }
   1104                      }
   1105                      
   1106                      /* Indication of this event still occurs at the ANT message period, so 
   1107                      an ANT_TICK message should be queued to the application message list.
   1108                      Overwrite au8MessageCopy with the ANT_TICK message data. */
   1109                      AntTick(EVENT_RX_FAIL);
   \                     ??AntProcessMessage_28: (+1)
   \   00000178   0x2002             MOVS     R0,#+2
   \   0000017A   0x.... 0x....      BL       AntTick
   1110                      break;
   \   0000017E   0xE027             B.N      ??AntProcessMessage_20
   1111                    }
   1112          
   1113                    case EVENT_TX: /* ANT has sent a data message */
   1114                    {
   1115                      /* If this is a master device, then EVENT_TX means it's time to queue the 
   1116                      next message */
   1117                      if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_23: (+1)
   \   00000180   0x....             LDR.N    R0,??DataTable16
   \   00000182   0x7840             LDRB     R0,[R0, #+1]
   \   00000184   0x2810             CMP      R0,#+16
   \   00000186   0xD102             BNE.N    ??AntProcessMessage_29
   1118                      {
   1119                        AntTick(EVENT_TX);
   \   00000188   0x2003             MOVS     R0,#+3
   \   0000018A   0x.... 0x....      BL       AntTick
   1120                      }
   1121                      break;
   \                     ??AntProcessMessage_29: (+1)
   \   0000018E   0xE01F             B.N      ??AntProcessMessage_20
   1122                    } 
   1123          
   1124                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1125                    { 
   1126                      G_u32AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_24: (+1)
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \   00000196   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   0000019E   0x6008             STR      R0,[R1, #+0]
   1127          
   1128                      AntTick(EVENT_TRANSFER_TX_COMPLETED);
   \   000001A0   0x2005             MOVS     R0,#+5
   \   000001A2   0x.... 0x....      BL       AntTick
   1129                      break;
   \   000001A6   0xE013             B.N      ??AntProcessMessage_20
   1130                    } 
   1131          
   1132                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1133                    { 
   1134          
   1135                      /* Regardless of complete or fail, it is time to send the next message */
   1136                      AntTick(EVENT_TRANSFER_TX_FAILED);
   \                     ??AntProcessMessage_25: (+1)
   \   000001A8   0x2006             MOVS     R0,#+6
   \   000001AA   0x.... 0x....      BL       AntTick
   1137                      break;
   \   000001AE   0xE00F             B.N      ??AntProcessMessage_20
   1138                    } 
   1139          
   1140                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1141                    {
   1142                      G_u32AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN;
   \                     ??AntProcessMessage_26: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   000001B4   0x6800             LDR      R0,[R0, #+0]
   \   000001B6   0xF430 0x2000      BICS     R0,R0,#0x80000
   \   000001BA   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   000001BE   0x6008             STR      R0,[R1, #+0]
   1143                      break;
   \   000001C0   0xE006             B.N      ??AntProcessMessage_20
   1144                    }
   1145                    
   1146                    /* All other messages are unexpected for now */
   1147                    default:
   1148                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \                     ??AntProcessMessage_27: (+1)
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001CC   0x....             LDR.N    R1,??DataTable19_29
   \   000001CE   0x6008             STR      R0,[R1, #+0]
   1149                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1150                } /* end else RF event */
   1151                break; 
   \                     ??AntProcessMessage_20: (+1)
   \   000001D0   0xE03B             B.N      ??AntProcessMessage_30
   1152              } /* end case MESG_RESPONSE_EVENT_ID */
   1153          
   1154              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1155              { 
   1156                AntQueueApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA]);
   \                     ??AntProcessMessage_8: (+1)
   \   000001D2   0xF10D 0x0103      ADD      R1,SP,#+3
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x.... 0x....      BL       AntQueueApplicationMessage
   1157          
   1158                /* If this is a slave device, then a data message received means it's time to send */
   1159                if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_SLAVE)
   \   000001DC   0x....             LDR.N    R0,??DataTable16
   \   000001DE   0x7840             LDRB     R0,[R0, #+1]
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD102             BNE.N    ??AntProcessMessage_31
   1160                {
   1161                  AntTick(RESPONSE_NO_ERROR);
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x.... 0x....      BL       AntTick
   1162                }
   1163                
   1164                break;
   \                     ??AntProcessMessage_31: (+1)
   \   000001EA   0xE02E             B.N      ??AntProcessMessage_30
   1165              } /* end case MESG_ACKNOWLEDGED_DATA_ID */
   1166          
   1167              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1168              { 
   1169                /* Put the data message into the application data buffer */ 
   1170                AntQueueApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA]);
   \                     ??AntProcessMessage_7: (+1)
   \   000001EC   0xF10D 0x0103      ADD      R1,SP,#+3
   \   000001F0   0x2001             MOVS     R0,#+1
   \   000001F2   0x.... 0x....      BL       AntQueueApplicationMessage
   1171          
   1172                /* If this is a slave device, then a data message received means it's time to send */
   1173                if(G_stAntSetupData.AntChannelType == CHANNEL_TYPE_SLAVE)
   \   000001F6   0x....             LDR.N    R0,??DataTable16
   \   000001F8   0x7840             LDRB     R0,[R0, #+1]
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD102             BNE.N    ??AntProcessMessage_32
   1174                {
   1175                  AntTick(RESPONSE_NO_ERROR);
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x.... 0x....      BL       AntTick
   1176                }
   1177                break;
   \                     ??AntProcessMessage_32: (+1)
   \   00000204   0xE021             B.N      ??AntProcessMessage_30
   1178              } /* end case MESG_BROADCAST_DATA_ID */
   1179              
   1180              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1181              { 
   1182                break;
   \                     ??AntProcessMessage_9: (+1)
   \   00000206   0xE020             B.N      ??AntProcessMessage_30
   1183              } /* end case ChannelStatus_CMD */
   1184              
   1185              case MESG_VERSION_ID:
   1186              {
   1187                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \   00000208   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_33: (+1)
   \   0000020A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020C   0x280A             CMP      R0,#+10
   \   0000020E   0xDA08             BGE.N    ??AntProcessMessage_34
   1188                {
   1189                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \   00000210   0xA900             ADD      R1,SP,#+0
   \   00000212   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000214   0x1841             ADDS     R1,R0,R1
   \   00000216   0x7889             LDRB     R1,[R1, #+2]
   \   00000218   0x....             LDR.N    R2,??DataTable19_15
   \   0000021A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000021C   0x5481             STRB     R1,[R0, R2]
   1190                }
   \   0000021E   0x1C40             ADDS     R0,R0,#+1
   \   00000220   0xE7F3             B.N      ??AntProcessMessage_33
   1191                
   1192                /* If we get a version message, we know that ANT comms is good */
   1193                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_34: (+1)
   \   00000222   0x....             LDR.N    R0,??DataTable19_13
   \   00000224   0x6800             LDR      R0,[R0, #+0]
   \   00000226   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000022A   0x....             LDR.N    R1,??DataTable19_13
   \   0000022C   0x6008             STR      R0,[R1, #+0]
   1194                break;
   \   0000022E   0xE00C             B.N      ??AntProcessMessage_30
   1195              } /* end case MESG_VERSION_ID */
   1196          
   1197              case MESG_RESTART_ID:
   1198              {
   1199                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_10: (+1)
   \   00000230   0x....             LDR.N    R0,??DataTable19_29
   \   00000232   0x6800             LDR      R0,[R0, #+0]
   \   00000234   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000238   0x....             LDR.N    R1,??DataTable19_29
   \   0000023A   0x6008             STR      R0,[R1, #+0]
   1200                break;
   \   0000023C   0xE005             B.N      ??AntProcessMessage_30
   1201              } /* end case MESG_RESTART_ID */
   1202              
   1203              default:
   1204                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_11: (+1)
   \   0000023E   0x....             LDR.N    R0,??DataTable19_29
   \   00000240   0x6800             LDR      R0,[R0, #+0]
   \   00000242   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000246   0x....             LDR.N    R1,??DataTable19_29
   \   00000248   0x6008             STR      R0,[R1, #+0]
   1205            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1206                     
   1207            return(0);
   \                     ??AntProcessMessage_30: (+1)
   \   0000024A   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \   0000024C   0xB005             ADD      SP,SP,#+20
   \   0000024E   0xBD30             POP      {R4,R5,PC}       ;; return
   1208            
   1209          } /* end AntProcessMessage() */
   1210          
   1211          
   1212          /*-----------------------------------------------------------------------------/
   1213          Function: AntTick
   1214          
   1215          Description:
   1216          Queues an ANT_TICK message to the application message queue.
   1217          
   1218          Requires:
   1219            - u8Code_ is payload byte indicating system info that may be relavent to the application
   1220          
   1221          Promises:
   1222            - A MESSAGE_ANT_TICK is queued to G_sAntApplicationMsgList
   1223          */

   \                                 In section .text, align 2, keep-with-next
   1224          static void AntTick(u8 u8Code_)
   1225          {
   \                     AntTick: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1226            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1227          
   1228            /* Update data to communicate the ANT_TICK to the application */
   1229            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1230            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = u8Code_;
   \   0000000A   0xF88D 0x4001      STRB     R4,[SP, #+1]
   1231            au8Message[ANT_TICK_MSG_SENTINEL1_INDEX]        = MESSAGE_ANT_TICK;
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1232            au8Message[ANT_TICK_MSG_SENTINEL2_INDEX]        = MESSAGE_ANT_TICK;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1233            au8Message[ANT_TICK_MSG_SENTINEL3_INDEX]        = MESSAGE_ANT_TICK;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1234            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \   00000020   0x....             LDR.N    R0,??DataTable19_43
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1235            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \   00000028   0x....             LDR.N    R0,??DataTable19_42
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1236            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \   00000030   0x....             LDR.N    R0,??DataTable19_41
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1237          
   1238            AntQueueApplicationMessage(ANT_TICK, &au8Message[BUFFER_INDEX_MESG_DATA]);
   \   00000038   0xF10D 0x0103      ADD      R1,SP,#+3
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x.... 0x....      BL       AntQueueApplicationMessage
   1239          
   1240          } /* end AntTick() */
   \   00000042   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1241          
   1242          
   1243          /*-----------------------------------------------------------------------------/
   1244          Function: AntQueueApplicationMessage
   1245          
   1246          Description:
   1247          Creates a new ANT data message structure and adds it to G_sAntApplicationMsgList.
   1248          
   1249          Requires:
   1250            - eMessageType_ specifies the type of message
   1251            - pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1252            - psTargetList_ is a pointer to the list pointer that is being updated
   1253            - Enough space is available on the heap
   1254          
   1255          Promises:
   1256            - A new list item in the target linked list is created and inserted at the end
   1257              of the list.
   1258            - If the list size goes over the maximum, then the first item in the list is deleted.
   1259            - Returns TRUE if the entry is added successfully.
   1260            - Returns FALSE on error.
   1261          */

   \                                 In section .text, align 2, keep-with-next
   1262          static bool AntQueueApplicationMessage(AntApplicationMessageType eMessageType_, u8 *pu8DataSource_)
   1263          {
   \                     AntQueueApplicationMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1264            AntApplicationMsgListType *psNewMessage;
   1265            AntApplicationMsgListType *psListParser;
   1266            u8 u8MessageCount;
   1267            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable19_44
   \   0000000E   0x222B             MOVS     R2,#+43
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy
   1268            
   1269            /* Allocate space for the new message - always do maximum message size */
   1270            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \   00000014   0x2014             MOVS     R0,#+20
   \   00000016   0x.... 0x....      BL       malloc
   \   0000001A   0x0006             MOVS     R6,R0
   1271            if (psNewMessage == NULL)
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD104             BNE.N    ??AntQueueApplicationMessage_0
   1272            {
   1273              DebugPrintf(au8AddMessageFailMsg);
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       DebugPrintf
   1274              return(FALSE);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE035             B.N      ??AntQueueApplicationMessage_1
   1275            }
   1276            
   1277            /* Fill in all the fields of the newly allocated message structure */
   1278            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueApplicationMessage_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueApplicationMessage_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2808             CMP      R0,#+8
   \   00000030   0xDA06             BGE.N    ??AntQueueApplicationMessage_3
   1279            {
   1280              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x5D41             LDRB     R1,[R0, R5]
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x1982             ADDS     R2,R0,R6
   \   0000003A   0x7151             STRB     R1,[R2, #+5]
   1281            }
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0xE7F5             B.N      ??AntQueueApplicationMessage_2
   1282            
   1283            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueApplicationMessage_3: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable17
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6030             STR      R0,[R6, #+0]
   1284            psNewMessage->eMessageType  = eMessageType_;
   \   00000046   0x7134             STRB     R4,[R6, #+4]
   1285            psNewMessage->psNextMessage = NULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6130             STR      R0,[R6, #+16]
   1286          
   1287            /* Insert into an empty list */
   1288            if(G_sAntApplicationMsgList == NULL)
   \   0000004C   0x....             LDR.N    R0,??DataTable19_8
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD102             BNE.N    ??AntQueueApplicationMessage_4
   1289            {
   1290              G_sAntApplicationMsgList = psNewMessage;
   \   00000054   0x....             LDR.N    R0,??DataTable19_8
   \   00000056   0x6006             STR      R6,[R0, #+0]
   \   00000058   0xE01C             B.N      ??AntQueueApplicationMessage_5
   1291            }
   1292          
   1293            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1294            else
   1295            {
   1296              psListParser = G_sAntApplicationMsgList;
   \                     ??AntQueueApplicationMessage_4: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable19_8
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x0007             MOVS     R7,R0
   1297              u8MessageCount = 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x4680             MOV      R8,R0
   1298              while( (psListParser->psNextMessage != NULL) && 
   1299                     (u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE) )
   \                     ??AntQueueApplicationMessage_6: (+1)
   \   00000064   0x6938             LDR      R0,[R7, #+16]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD008             BEQ.N    ??AntQueueApplicationMessage_7
   \   0000006A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006E   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000072   0xD203             BCS.N    ??AntQueueApplicationMessage_7
   1300              {
   1301                psListParser = psListParser->psNextMessage;
   \   00000074   0x693F             LDR      R7,[R7, #+16]
   1302                u8MessageCount++;
   \   00000076   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000007A   0xE7F3             B.N      ??AntQueueApplicationMessage_6
   1303              }
   1304              
   1305              /* Handle a full list */
   1306              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueApplicationMessage_7: (+1)
   \   0000007C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000080   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000084   0xD201             BCS.N    ??AntQueueApplicationMessage_8
   1307              {
   1308                /* Insert the new message at the end of the list */
   1309                psListParser->psNextMessage = psNewMessage;
   \   00000086   0x613E             STR      R6,[R7, #+16]
   \   00000088   0xE004             B.N      ??AntQueueApplicationMessage_5
   1310              }
   1311              else
   1312              {
   1313                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueApplicationMessage_8: (+1)
   \   0000008A   0xA800             ADD      R0,SP,#+0
   \   0000008C   0x.... 0x....      BL       DebugPrintf
   1314                return(FALSE);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE000             B.N      ??AntQueueApplicationMessage_1
   1315              }
   1316            }
   1317              
   1318            return(TRUE);
   \                     ??AntQueueApplicationMessage_5: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \                     ??AntQueueApplicationMessage_1: (+1)
   \   00000096   0xB00C             ADD      SP,SP,#+48
   \   00000098   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1319              
   1320          } /* end AntQueueApplicationMessage() */
   1321          
   1322          
   1323          /*-----------------------------------------------------------------------------/
   1324          Function: AntDeQueueOutgoingMessage
   1325          
   1326          Description:
   1327          Removes the first entry of Ant_psDataOutgoingMsgList.
   1328          
   1329          Requires:
   1330            - 
   1331          
   1332          Promises:
   1333            - Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage 
   1334            and the memory is freed
   1335          */

   \                                 In section .text, align 2, keep-with-next
   1336          static void AntDeQueueOutgoingMessage(void)
   1337          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1338            AntOutgoingMessageListType *psMessageToKill;
   1339            
   1340            if(Ant_psDataOutgoingMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable19_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1341            {
   1342              psMessageToKill = Ant_psDataOutgoingMsgList;
   \   0000000A   0x....             LDR.N    R0,??DataTable19_9
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   1343              Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage;
   \   00000010   0x....             LDR.N    R0,??DataTable19_9
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x....             LDR.N    R1,??DataTable19_9
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1344            
   1345              /* The doomed message is properly disconnected, so kill it */
   1346              free(psMessageToKill);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       free
   1347            }
   1348            
   1349          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   1350          
   1351          
   1352          /***********************************************************************************************************************
   1353          ##### ANT State Machine Definition                                             
   1354          ***********************************************************************************************************************/
   1355          
   1356          /*------------------------------------------------------------------------------
   1357          Idle state that will process new messages if any are present, monitors ANT
   1358          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1359          Incoming messages from ANT always get priority.  
   1360          */

   \                                 In section .text, align 4, keep-with-next
   1361          void AntSM_Idle(void)
   1362          {
   \                     AntSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1363            u32 u32MsgBitMask = 0x01;
   \   00000002   0x2401             MOVS     R4,#+1
   1364            u8 u8MsgIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1365            
   1366            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1367            static u8 au8AntFlagMessages[][20] = 
   1368            {/*012345678901234567\n\r*/
   1369              "ANT flags:\n\r ",
   1370              "Length mismatch\n\r",
   1371              "Command error\n\r",
   1372              "Unexpected event\n\r",
   1373              "Unexpected message\n\r"
   1374            };
   1375            
   1376            /* Check flags */
   1377            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \   00000006   0x....             LDR.N    R0,??DataTable19_29
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0400             LSLS     R0,R0,#+16
   \   0000000C   0xD01E             BEQ.N    ??AntSM_Idle_0
   1378            {
   1379              /* At least one flag is set, so print header and parse out */
   1380              DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   0000000E   0x....             LDR.N    R0,??DataTable19_45
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000018   0x.... 0x....      BL       DebugPrintf
   1381              u8MsgIndex++;
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   1382              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \   0000001E   0x2600             MOVS     R6,#+0
   \                     ??AntSM_Idle_1: (+1)
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E04             CMP      R6,#+4
   \   00000024   0xDA12             BGE.N    ??AntSM_Idle_0
   1383              {
   1384                /* Check if current flag is set */
   1385                if(G_u32AntFlags & u32MsgBitMask)
   \   00000026   0x....             LDR.N    R0,??DataTable19_29
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x4220             TST      R0,R4
   \   0000002C   0xD00B             BEQ.N    ??AntSM_Idle_2
   1386                {
   1387                  /* Print the error message and clear the flag */
   1388                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   0000002E   0x....             LDR.N    R0,??DataTable19_45
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2114             MOVS     R1,#+20
   \   00000034   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000038   0x.... 0x....      BL       DebugPrintf
   1389                  G_u32AntFlags &= ~u32MsgBitMask;
   \   0000003C   0x....             LDR.N    R0,??DataTable19_29
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x43A0             BICS     R0,R0,R4
   \   00000042   0x....             LDR.N    R1,??DataTable19_29
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1390                }
   1391                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_2: (+1)
   \   00000046   0x0064             LSLS     R4,R4,#+1
   1392              }
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0xE7E9             B.N      ??AntSM_Idle_1
   1393            }
   1394            
   1395            /* Process messages received from ANT */
   1396            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \   0000004C   0x.... 0x....      BL       AntProcessMessage
   1397          
   1398            /* Handle messages coming in from ANT */
   1399            if( IS_SEN_ASSERTED() )
   \   00000050   0x....             LDR.N    R0,??DataTable19
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x07C0             LSLS     R0,R0,#+31
   \   00000056   0xD504             BPL.N    ??AntSM_Idle_3
   1400            {
   1401              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \   00000058   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \   0000005C   0x....             LDR.N    R1,??DataTable19_5
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE016             B.N      ??AntSM_Idle_4
   1402            }
   1403            
   1404            /* Send a message if the system is ready and there is one to send */ 
   1405            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1406                     (Ant_psDataOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_3: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable19_27
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD112             BNE.N    ??AntSM_Idle_4
   \   0000006A   0x....             LDR.N    R0,??DataTable19_9
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD00E             BEQ.N    ??AntSM_Idle_4
   1407            {
   1408              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1409              if(AntTxMessage(Ant_psDataOutgoingMsgList->au8MessageData))
   \   00000072   0x....             LDR.N    R0,??DataTable19_9
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x1D00             ADDS     R0,R0,#+4
   \   00000078   0x.... 0x....      BL       AntTxMessage
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD007             BEQ.N    ??AntSM_Idle_4
   1410              {
   1411                Ant_u32TxTimeoutCounter = G_u32SystemTime1ms;
   \   00000080   0x....             LDR.N    R0,??DataTable19_46
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x....             LDR.N    R1,??DataTable19_47
   \   00000086   0x6008             STR      R0,[R1, #+0]
   1412                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \   00000088   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \   0000008C   0x....             LDR.N    R1,??DataTable19_5
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   1413              }
   1414              else
   1415              {
   1416                /* Transmit attempt failed.  !!!! Do something? */
   1417              }
   1418            }
   1419            
   1420          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_4: (+1)
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8AntFlagMessages:
   \   00000000   0x41 0x4E          DC8 "ANT flags:\012\015 "
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \   00000026   0x00 0x00          DC8 0, 0
   \   00000028   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000004F   0x00               DC8 0
   \   00000050   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \   00000058   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \   00000060   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1421          
   1422          
   1423          /*------------------------------------------------------------------------------
   1424          Completely receive an ANT message.  Reception is very fast and should complete
   1425          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1426          but giving it its own state minimizes the total time and allows for easier future
   1427          updates should they be required.
   1428          */

   \                                 In section .text, align 4, keep-with-next
   1429          void AntSM_ReceiveMessage(void)
   1430          {
   \                     AntSM_ReceiveMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1431            Ant_DebugRxMessageCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable19_48
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable19_48
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1432          
   1433            AntRxMessage();
   \   0000000C   0x.... 0x....      BL       AntRxMessage
   1434            
   1435            G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \   00000010   0x....             LDR.N    R0,??DataTable19_29
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   00000018   0x....             LDR.N    R1,??DataTable19_29
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1436            Ant_pfnStateMachine = AntSM_Idle;
   \   0000001C   0x....             LDR.N    R0,??DataTable19_49
   \   0000001E   0x....             LDR.N    R1,??DataTable19_5
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1437          
   1438          } /* end AntSM_ReceiveMessage() */
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   1439          
   1440          
   1441          /*------------------------------------------------------------------------------
   1442          Wait for an ANT message to be transmitted.  This state only occurs once the 
   1443          handshaking transaction has been completed and transmit to ANT is verified 
   1444          and underway.
   1445          */

   \                                 In section .text, align 4, keep-with-next
   1446          void AntSM_TransmitMessage(void)
   1447          {
   \                     AntSM_TransmitMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1448            static u8 au8TxTimeoutMsg[] = "\n\rTransmit message timeout\n\r";
   1449            MessageStateType eCurrentMsgStatus;
   1450            
   1451            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \   00000002   0x....             LDR.N    R0,??DataTable19_27
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       QueryMessageStatus
   \   0000000A   0x0004             MOVS     R4,R0
   1452            switch(eCurrentMsgStatus)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD004             BEQ.N    ??AntSM_TransmitMessage_0
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD111             BNE.N    ??AntSM_TransmitMessage_1
   1453            {
   1454              case TIMEOUT:
   1455                /* !!!! Consider re-initializing ANT here */
   1456                DebugPrintf(au8TxTimeoutMsg);
   \                     ??AntSM_TransmitMessage_2: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable19_50
   \   0000001A   0x.... 0x....      BL       DebugPrintf
   1457                
   1458                /* Fall through */
   1459                
   1460              case COMPLETE:
   1461                /* Kill the message and update flags */
   1462                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_0: (+1)
   \   0000001E   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1463                Ant_u32CurrentTxMessageToken = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable19_27
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1464                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000028   0x....             LDR.N    R0,??DataTable19_29
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000030   0x....             LDR.N    R1,??DataTable19_29
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1465          
   1466                Ant_pfnStateMachine = AntSM_Idle;
   \   00000034   0x....             LDR.N    R0,??DataTable19_49
   \   00000036   0x....             LDR.N    R1,??DataTable19_5
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1467                break;
   \   0000003A   0xE7FF             B.N      ??AntSM_TransmitMessage_3
   1468                
   1469              default:
   1470                /* Do nothing for now */
   1471                break;
   1472                
   1473            } /* end switch */
   1474            
   1475          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_1: (+1)
   \                     ??AntSM_TransmitMessage_3: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8TxTimeoutMsg:
   \   00000000   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1476          
   1477          
   1478          /*------------------------------------------------------------------------------
   1479          Do-nothing state if ANT is dead (requires restart to retry initialization)
   1480          */

   \                                 In section .text, align 4, keep-with-next
   1481          void AntSM_NoResponse(void)
   1482          {
   1483            
   1484          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x400E0E34         DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x000F4241         DC32     0xf4241

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer+0x100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x400E0E10         DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x........         DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x........         DC32     Ant_psDataOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x........         DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x400E0E00         DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x........         DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_15:
   \   00000000   0x........         DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_16:
   \   00000000   0x........         DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_17:
   \   00000000   0x400E0C04         DC32     0x400e0c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_18:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_19:
   \   00000000   0x400E0E04         DC32     0x400e0e04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_20:
   \   00000000   0x400E0C14         DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_21:
   \   00000000   0x400E0E14         DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_22:
   \   00000000   0x........         DC32     G_u32SystemTime1s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_23:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_24:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_25:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_26:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_27:
   \   00000000   0x........         DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_28:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_29:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_30:
   \   00000000   0x........         DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_31:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_32:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_33:
   \   00000000   0x........         DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_34:
   \   00000000   0x........         DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_35:
   \   00000000   0x........         DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_36:
   \   00000000   0x........         DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_37:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_38:
   \   00000000   0x........         DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_39:
   \   00000000   0x........         DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_40:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_41:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_42:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_43:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_44:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_45:
   \   00000000   0x........         DC32     ??au8AntFlagMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_46:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_47:
   \   00000000   0x........         DC32     Ant_u32TxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_48:
   \   00000000   0x........         DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_49:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_50:
   \   00000000   0x........         DC32     ??au8TxTimeoutMsg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x0D 0x0A          DC8 "\015\012ANT expected msg fail\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       4   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      56   AntExpectResponse
        56   -> AntDeQueueOutgoingMessage
        56   -> AntProcessMessage
        56   -> AntRxMessage
        56   -> DebugPrintf
        56   -> IsTimeUp
        56   -> QueryMessageStatus
        56   -> __aeabi_memcpy
      16   AntInitialize
        16   -> AntSyncSerialInitialize
        16   -> DebugLineFeed
        16   -> DebugPrintf
        16   -> SspRequest
      32   AntProcessMessage
        32   -> AdvanceAntRxBufferUnreadMsgPointer
        32   -> AntQueueApplicationMessage
        32   -> AntTick
        32   -> DebugPrintf
      72   AntQueueApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      64   AntQueueOutgoingMessage
        64   -> DebugPrintf
        64   -> __aeabi_memcpy4
        64   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       0   AntRxFlowControlCallback
      40   AntRxMessage
        40   -> AdvanceAntRxBufferCurrentChar
        40   -> AdvanceAntRxBufferUnreadMsgPointer
        40   -> AntAbortMessage
        40   -> DebugPrintf
        40   -> __aeabi_memcpy
      16   AntSM_Idle
        16   -> AntProcessMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
       8   AntSM_TransmitMessage
         8   -> AntDeQueueOutgoingMessage
         8   -> DebugPrintf
         8   -> QueryMessageStatus
      24   AntSyncSerialInitialize
        24   -> AntCalculateTxChecksum
        24   -> AntExpectResponse
        24   -> AntProcessMessage
        24   -> AntRxMessage
        24   -> AntTxMessage
        24   -> IsTimeUp
      16   AntTick
        16   -> AntQueueApplicationMessage
       0   AntTxFlowControlCallback
     120   AntTxMessage
       120   -> AdvanceAntRxBufferCurrentChar
       120   -> AdvanceAntRxBufferUnreadMsgPointer
       120   -> DebugPrintf
       120   -> SspWriteData
       120   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_32
       4  ??DataTable19_33
       4  ??DataTable19_34
       4  ??DataTable19_35
       4  ??DataTable19_36
       4  ??DataTable19_37
       4  ??DataTable19_38
       4  ??DataTable19_39
       4  ??DataTable19_4
       4  ??DataTable19_40
       4  ??DataTable19_41
       4  ??DataTable19_42
       4  ??DataTable19_43
       4  ??DataTable19_44
       4  ??DataTable19_45
       4  ??DataTable19_46
       4  ??DataTable19_47
       4  ??DataTable19_48
       4  ??DataTable19_49
       4  ??DataTable19_5
       4  ??DataTable19_50
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      20  ?_0
      36  ?_1
      24  ?_2
      20  ?_3
      20  ?_4
      28  ?_5
      40  ?_6
      44  ?_7
       8  ?_8
      40  AdvanceAntRxBufferCurrentChar
      40  AdvanceAntRxBufferUnreadMsgPointer
      44  AntAbortMessage
      36  AntCalculateTxChecksum
      42  AntDeQueueApplicationMessage
      34  AntDeQueueOutgoingMessage
     248  AntExpectResponse
     384  AntInitialize
     592  AntProcessMessage
     156  AntQueueApplicationMessage
     180  AntQueueOutgoingMessage
      12  AntRunActiveState
      96  AntRxFlowControlCallback
     504  AntRxMessage
     146  AntSM_Idle
       2  AntSM_NoResponse
      36  AntSM_ReceiveMessage
      62  AntSM_TransmitMessage
     246  AntSyncSerialInitialize
      68  AntTick
      48  AntTxFlowControlCallback
     424  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psDataOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimeoutCounter
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
      20  G_au8AntMessageAssign
      20  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      64  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      20  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      28  G_au8AntMessageUnhandled
       4  G_sAntApplicationMsgList
      12  G_stAntSetupData
       4  G_u32AntFlags
     100  au8AntFlagMessages
      32  au8TxTimeoutMsg

 
   392 bytes in section .bss
   400 bytes in section .data
   240 bytes in section .rodata
 3 720 bytes in section .text
 
 3 720 bytes of CODE  memory
   240 bytes of CONST memory
   792 bytes of DATA  memory

Errors: none
Warnings: 2
