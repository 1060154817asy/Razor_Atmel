###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        27/Oct/2015  16:33:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MPG Source\Git\Razor_Atmel\firmware_mpg_common\drivers\utilities.c
#    Command line =  
#        "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpg_common\drivers\utilities.c"
#        --preprocess=cl "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\" -lC
#        "D:\MPG Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\"
#        -o "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\" -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\bsp\" -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\drivers\" -I
#        "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\application\" -I
#        "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\"
#        -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\"
#        -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\"
#        -I "D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\List\utilities.lst
#    Object file  =  
#        D:\MPG
#        Source\Git\Razor_Atmel\firmware_mpgl1\iar_7_20_1\Debug\Obj\utilities.o
#
###############################################################################

D:\MPG Source\Git\Razor_Atmel\firmware_mpg_common\drivers\utilities.c
      1          /***********************************************************************************************************************
      2          File: utilities.c                                                                
      3          
      4          Description:
      5          Various useful functions.
      6          
      7          API:
      8          bool IsTimeUp(u32 *pu32SavedTick_, u32 u32Period_)
      9          Calculates if u32Period_ time has passed (in ms) using comparison of
     10          pu32SavedTick_ against G_u32SystemTime1ms.  
     11          e.g. do nothing until 1 second has elapsed
     12          u32ApplicationTimer = G_u32SystemTime1ms;
     13          if( !IsTimeUp(&u32ApplicationTimer, 1000)
     14          {
     15            // Time has elapsed so update timer for next period and do whatever
     16            u32ApplicationTimer = G_u32SystemTime1ms;
     17          }
     18          
     19          
     20          ***********************************************************************************************************************/
     21          
     22          #include "configuration.h"
     23          
     24          /***********************************************************************************************************************
     25          Global variable definitions with scope across entire project.
     26          All Global variable names shall start with "G_"
     27          ***********************************************************************************************************************/
     28          /* New variables */

   \                                 In section .data, align 4
     29          u8 G_au8MessageOK[]   = MESSAGE_OK;            /* Common "OK" message */
   \                     G_au8MessageOK:
   \   00000000   0x4F 0x4B          DC8 "OK\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     30          u8 G_au8MessageFAIL[] = MESSAGE_FAIL;          /* Common "FAIL" message */
   \                     G_au8MessageFAIL:
   \   00000000   0x46 0x41          DC8 "FAIL\015\012"
   \              0x49 0x4C    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .data, align 4
     31          u8 G_au8MessageON[]   = MESSAGE_ON;            /* Common "ON" message */
   \                     G_au8MessageON:
   \   00000000   0x4F 0x4E          DC8 "ON\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     32          u8 G_au8MessageOFF[]  = MESSAGE_OFF;           /* Common "OFF" message */
   \                     G_au8MessageOFF:
   \   00000000   0x4F 0x46          DC8 "OFF\015\012"
   \              0x46 0x0D    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
     33          
     34          
     35          /*--------------------------------------------------------------------------------------------------------------------*/
     36          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     37          extern volatile u32 G_u32SystemTime1ms;        /* From scroll-ehw-ae.c */
     38          extern volatile u32 G_u32SystemTime1s;         /* From scroll-ehw-ae.c */
     39          
     40          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     41          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     42          
     43          
     44          /***********************************************************************************************************************
     45          Global variable definitions with scope limited to this local application.
     46          Variable names shall start with "Util_" and be declared as static.
     47          ***********************************************************************************************************************/
     48          
     49          
     50          /***********************************************************************************************************************
     51          Function Definitions
     52          ***********************************************************************************************************************/
     53          /*--------------------------------------------------------------------------------------------------------------------*/
     54          /* Public Functions */
     55          /*--------------------------------------------------------------------------------------------------------------------*/
     56          
     57          
     58          /*-----------------------------------------------------------------------------/
     59          Function: ASCIIHexCharToChar
     60          
     61          Description:
     62          Determines the numerical value of a hexidecimal ASCII char of that number
     63          ('0' - 'F' or '0' - 'f' -> 0 - 15).
     64          
     65          Requires:
     66            - Standard ASCII table is in use
     67           
     68          Promises:
     69            - If valid 0-9, A-F or a-f, returns the numerical value of the ASCII char
     70            - Otherwise returns 0xff
     71          */

   \                                 In section .text, align 2, keep-with-next
     72          u8 ASCIIHexCharToChar(u8 u8Char_)
     73          {
   \                     ASCIIHexCharToChar: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     74            if( (u8Char_ >= '0') && (u8Char_ <= '9') )
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2930             CMP      R1,#+48
   \   00000006   0xDB06             BLT.N    ??ASCIIHexCharToChar_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x293A             CMP      R1,#+58
   \   0000000C   0xDA03             BGE.N    ??ASCIIHexCharToChar_0
     75              return(u8Char_ - NUMBER_ASCII_TO_DEC);
   \   0000000E   0xF1B1 0x0030      SUBS     R0,R1,#+48
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xE014             B.N      ??ASCIIHexCharToChar_1
     76                 
     77            if( (u8Char_ >= 'A') && (u8Char_ <= 'F') )
   \                     ??ASCIIHexCharToChar_0: (+1)
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2941             CMP      R1,#+65
   \   0000001A   0xDB06             BLT.N    ??ASCIIHexCharToChar_2
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x2947             CMP      R1,#+71
   \   00000020   0xDA03             BGE.N    ??ASCIIHexCharToChar_2
     78              return(u8Char_ - UPPERCASE_ASCII_TO_DEC);
   \   00000022   0xF1B1 0x0037      SUBS     R0,R1,#+55
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE00A             B.N      ??ASCIIHexCharToChar_1
     79            
     80            if( (u8Char_ >= 'a') && (u8Char_ <= 'f') )
   \                     ??ASCIIHexCharToChar_2: (+1)
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x2961             CMP      R1,#+97
   \   0000002E   0xDB06             BLT.N    ??ASCIIHexCharToChar_3
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x2967             CMP      R1,#+103
   \   00000034   0xDA03             BGE.N    ??ASCIIHexCharToChar_3
     81              return(u8Char_ - LOWERCASE_ASCII_TO_DEC);
   \   00000036   0xF1B1 0x0057      SUBS     R0,R1,#+87
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xE000             B.N      ??ASCIIHexCharToChar_1
     82            
     83            return(0xff);
   \                     ??ASCIIHexCharToChar_3: (+1)
   \   0000003E   0x20FF             MOVS     R0,#+255
   \                     ??ASCIIHexCharToChar_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
     84          
     85          } /* end ASCIIHexChartoChar */
     86          
     87          
     88          /*-----------------------------------------------------------------------------/
     89          Function: HexToASCIICharUpper
     90          
     91          Description:
     92          Determines the ASCII char of a single digit number
     93          0 - 15 -> '0' - 'F'
     94          
     95          Requires:
     96            - Standard ASCII table is in use
     97           
     98          Promises:
     99            - If valid 0-15, returns the corresponding ASCII hex char 0-9, A-F
    100            - Otherwise returns 0xff
    101          */

   \                                 In section .text, align 2, keep-with-next
    102          u8 HexToASCIICharUpper(u8 u8Char_)
    103          {
   \                     HexToASCIICharUpper: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    104            u8 u8ReturnValue = 0xFF;
   \   00000002   0x20FF             MOVS     R0,#+255
    105            
    106            if( u8Char_ <= 9 )
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x290A             CMP      R1,#+10
   \   00000008   0xDA03             BGE.N    ??HexToASCIICharUpper_0
    107            {
    108              u8ReturnValue = u8Char_ + NUMBER_ASCII_TO_DEC;
   \   0000000A   0xF111 0x0230      ADDS     R2,R1,#+48
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xE008             B.N      ??HexToASCIICharUpper_1
    109            }
    110            
    111            else if( (u8Char_ >= 10) && (u8Char_ <= 15) )
   \                     ??HexToASCIICharUpper_0: (+1)
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x290A             CMP      R1,#+10
   \   00000016   0xDB05             BLT.N    ??HexToASCIICharUpper_1
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xDA02             BGE.N    ??HexToASCIICharUpper_1
    112            {
    113              u8ReturnValue = u8Char_ + UPPERCASE_ASCII_TO_DEC;
   \   0000001E   0xF111 0x0237      ADDS     R2,R1,#+55
   \   00000022   0x0010             MOVS     R0,R2
    114            }
    115            
    116            return(u8ReturnValue);
   \                     ??HexToASCIICharUpper_1: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x4770             BX       LR               ;; return
    117          
    118          } /* end HexToASCIICharUpper */
    119          
    120          
    121          /*-----------------------------------------------------------------------------/
    122          Function: HexToASCIICharLower
    123          
    124          Description:
    125          Determines the ASCII char of a single digit number
    126          0 - 15 -> '0' - 'f'
    127          
    128          Requires:
    129            - Standard ASCII table is in use
    130           
    131          Promises:
    132            - If valid 0-15, returns the corresponding ASCII hex char 0-9, a-f
    133            - Otherwise returns 0xFF
    134          */

   \                                 In section .text, align 2, keep-with-next
    135          u8 HexToASCIICharLower(u8 u8Char_)
    136          {
   \                     HexToASCIICharLower: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    137            u8 u8ReturnValue = 0xFF;
   \   00000002   0x20FF             MOVS     R0,#+255
    138            
    139            if( u8Char_ <= 9 )
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x290A             CMP      R1,#+10
   \   00000008   0xDA03             BGE.N    ??HexToASCIICharLower_0
    140            {
    141              u8ReturnValue = u8Char_ + NUMBER_ASCII_TO_DEC;
   \   0000000A   0xF111 0x0230      ADDS     R2,R1,#+48
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xE008             B.N      ??HexToASCIICharLower_1
    142            }
    143            
    144            else if( (u8Char_ >= 10) && (u8Char_ <= 15) )
   \                     ??HexToASCIICharLower_0: (+1)
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x290A             CMP      R1,#+10
   \   00000016   0xDB05             BLT.N    ??HexToASCIICharLower_1
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xDA02             BGE.N    ??HexToASCIICharLower_1
    145            {
    146              u8ReturnValue = u8Char_ + LOWERCASE_ASCII_TO_DEC;
   \   0000001E   0xF111 0x0257      ADDS     R2,R1,#+87
   \   00000022   0x0010             MOVS     R0,R2
    147            }
    148            
    149            return(u8ReturnValue);
   \                     ??HexToASCIICharLower_1: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x4770             BX       LR               ;; return
    150          
    151          } /* end HexToASCIICharLower */
    152          
    153          
    154          /*-----------------------------------------------------------------------------/
    155          Function: NumberToAscii
    156          
    157          Description:
    158          Converts a long into an ASCII string.  Maximum of 10 digits + NULL.
    159          
    160          Requires:
    161            - u32Number_ is the number to convert
    162            - *pu8AsciiString_ points to the destination string location
    163           
    164          Promises:
    165            - Null-terminated string of the number is loaded to pu8AsciiString_
    166            - Returns the number of digits
    167          */

   \                                 In section .text, align 2, keep-with-next
    168          u8 NumberToAscii(u32 u32Number_, u8* pu8AsciiString_)
    169          {
   \                     NumberToAscii: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    170            bool bFoundDigit = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
    171            u8 au8AsciiNumber[11];
    172            u8 u8CharCount = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    173            u32 u32Divider = 1000000000;
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable0  ;; 0x3b9aca00
    174            u8 u8Temp;
    175            
    176            /* Parse out all the digits, start counting after leading zeros */
    177            for(u8 i = 0; i < 10; i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??NumberToAscii_0: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xDA1B             BGE.N    ??NumberToAscii_1
    178            {
    179              u8Temp = (u32Number_ / u32Divider);
   \   00000018   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000001C   0x4689             MOV      R9,R1
    180              
    181              /* Check for first non-leading zero */
    182              if(u8Temp != 0)
   \   0000001E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD001             BEQ.N    ??NumberToAscii_2
    183              {
    184                bFoundDigit = TRUE;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x000E             MOVS     R6,R1
    185              }
    186          
    187              /* As long as a non-leading zero has been found, add the ASCII char */
    188              if(bFoundDigit)
   \                     ??NumberToAscii_2: (+1)
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD005             BEQ.N    ??NumberToAscii_3
    189              {
    190                au8AsciiNumber[u8CharCount] = u8Temp + 0x30;
   \   00000032   0xF119 0x0130      ADDS     R1,R9,#+48
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x54B9             STRB     R1,[R7, R2]
    191                u8CharCount++;
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
    192              }
    193              
    194              /* Update for next iteration */
    195              u32Number_ %= u32Divider;
   \                     ??NumberToAscii_3: (+1)
   \   0000003E   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   00000042   0xFB08 0x4411      MLS      R4,R8,R1,R4
    196              u32Divider /= 10;
   \   00000046   0x210A             MOVS     R1,#+10
   \   00000048   0xFBB8 0xF8F1      UDIV     R8,R8,R1
    197            }
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0xE7E0             B.N      ??NumberToAscii_0
    198            
    199            /* Handle special case where u32Number == 0 */
    200            if(!bFoundDigit)
   \                     ??NumberToAscii_1: (+1)
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD104             BNE.N    ??NumberToAscii_4
    201            {
    202              u8CharCount = 1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x0007             MOVS     R7,R0
    203              au8AsciiNumber[0] = '0';
   \   0000005A   0x2030             MOVS     R0,#+48
   \   0000005C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    204            }
    205            
    206            /* Add the null and copy to destination */
    207            au8AsciiNumber[u8CharCount] = NULL;
   \                     ??NumberToAscii_4: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x5478             STRB     R0,[R7, R1]
    208            strcpy((char *)pu8AsciiString_, (const char*)au8AsciiNumber);
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       strcpy
    209            
    210            return(u8CharCount);
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    211          
    212          } /* end NumberToAscii() */
    213          
    214          
    215          /*-----------------------------------------------------------------------------/
    216          Function: SearchString
    217          
    218          Description:
    219          Searches a string for another string.  Finds only an exact match of the string (case sensitive).
    220          Character following matched string must be space, <CR> or <LF>.
    221          
    222          Requires:
    223            - Standard ASCII table is in use
    224            - pu8TargetString_ points to the start of a NULL, <CR> or <LF> terminated string to search
    225            - pu8MatchString_ points to the start of a NULL, <CR> or <LF> terminated string to be found in pu8TargetString_
    226           
    227          Promises:
    228            - Returns TRUE if the string is found
    229          */

   \                                 In section .text, align 2, keep-with-next
    230          bool SearchString(u8* pu8TargetString_, u8* pu8MatchString_)
    231          {
   \                     SearchString: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    232            u8* pu8MatchChar = pu8MatchString_;
   \   00000004   0x000B             MOVS     R3,R1
    233            u8* pu8TargetChar = pu8TargetString_;
   \   00000006   0x0014             MOVS     R4,R2
    234            
    235            do
    236            {
    237              /* Scan for the current character of pu8MatchString_ in pu8TargetString_ */
    238              while( (*pu8MatchChar != *pu8TargetChar) && (*pu8TargetChar != NULL) && 
    239                     (*pu8TargetChar != ASCII_LINEFEED) && (*pu8TargetChar != ASCII_CARRIAGE_RETURN) )
   \                     ??SearchString_0: (+1)
   \   00000008   0x7818             LDRB     R0,[R3, #+0]
   \   0000000A   0x7825             LDRB     R5,[R4, #+0]
   \   0000000C   0x42A8             CMP      R0,R5
   \   0000000E   0xD00A             BEQ.N    ??SearchString_1
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??SearchString_1
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x280A             CMP      R0,#+10
   \   0000001A   0xD004             BEQ.N    ??SearchString_1
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x280D             CMP      R0,#+13
   \   00000020   0xD001             BEQ.N    ??SearchString_1
    240              {
    241                pu8TargetChar++;
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0xE7F0             B.N      ??SearchString_0
    242              }
    243              
    244              /* Exit if we're at the end of the target string */
    245              if( (*pu8TargetChar == NULL) || 
    246                  (*pu8TargetChar == ASCII_LINEFEED) || (*pu8TargetChar == ASCII_CARRIAGE_RETURN) )
   \                     ??SearchString_1: (+1)
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD005             BEQ.N    ??SearchString_2
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x280A             CMP      R0,#+10
   \   00000030   0xD002             BEQ.N    ??SearchString_2
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x280D             CMP      R0,#+13
   \   00000036   0xD101             BNE.N    ??SearchString_3
    247              {
    248                return(FALSE);
   \                     ??SearchString_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE032             B.N      ??SearchString_4
    249              }
    250              
    251              /* If we found a match, look for next char */
    252              while ( *pu8MatchChar == *pu8TargetChar )
   \                     ??SearchString_3: (+1)
   \   0000003C   0x7818             LDRB     R0,[R3, #+0]
   \   0000003E   0x7825             LDRB     R5,[R4, #+0]
   \   00000040   0x42A8             CMP      R0,R5
   \   00000042   0xD118             BNE.N    ??SearchString_5
    253              {
    254                pu8MatchChar++;
   \   00000044   0x1C5B             ADDS     R3,R3,#+1
    255                pu8TargetChar++;
   \   00000046   0x1C64             ADDS     R4,R4,#+1
    256                
    257                /* At the end of the match string? */
    258                if( (*pu8MatchChar == NULL) || (*pu8MatchChar == ASCII_LINEFEED) || (*pu8MatchChar == ASCII_CARRIAGE_RETURN) )
   \   00000048   0x7818             LDRB     R0,[R3, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD005             BEQ.N    ??SearchString_6
   \   0000004E   0x7818             LDRB     R0,[R3, #+0]
   \   00000050   0x280A             CMP      R0,#+10
   \   00000052   0xD002             BEQ.N    ??SearchString_6
   \   00000054   0x7818             LDRB     R0,[R3, #+0]
   \   00000056   0x280D             CMP      R0,#+13
   \   00000058   0xD1F0             BNE.N    ??SearchString_3
    259                {
    260                  /* Check if the next character in pu8TargetChar is space, <CR>, <LF> or ':' */
    261                  if( (*pu8TargetChar == ' ') ||
    262                      (*pu8TargetChar == ASCII_CARRIAGE_RETURN) ||
    263                      (*pu8TargetChar == ASCII_LINEFEED) ||
    264                      (*pu8TargetChar == ':')  )
   \                     ??SearchString_6: (+1)
   \   0000005A   0x7820             LDRB     R0,[R4, #+0]
   \   0000005C   0x2820             CMP      R0,#+32
   \   0000005E   0xD008             BEQ.N    ??SearchString_7
   \   00000060   0x7820             LDRB     R0,[R4, #+0]
   \   00000062   0x280D             CMP      R0,#+13
   \   00000064   0xD005             BEQ.N    ??SearchString_7
   \   00000066   0x7820             LDRB     R0,[R4, #+0]
   \   00000068   0x280A             CMP      R0,#+10
   \   0000006A   0xD002             BEQ.N    ??SearchString_7
   \   0000006C   0x7820             LDRB     R0,[R4, #+0]
   \   0000006E   0x283A             CMP      R0,#+58
   \   00000070   0xD1E4             BNE.N    ??SearchString_3
    265                  {
    266                    return(TRUE);
   \                     ??SearchString_7: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE015             B.N      ??SearchString_4
    267                  }
    268                }
    269              }
    270          
    271              /* At the end of the target string? */
    272              if( (*pu8TargetChar == NULL) || (*pu8TargetChar == ASCII_LINEFEED) || (*pu8TargetChar == ASCII_CARRIAGE_RETURN) )
   \                     ??SearchString_5: (+1)
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD005             BEQ.N    ??SearchString_8
   \   0000007C   0x7820             LDRB     R0,[R4, #+0]
   \   0000007E   0x280A             CMP      R0,#+10
   \   00000080   0xD002             BEQ.N    ??SearchString_8
   \   00000082   0x7820             LDRB     R0,[R4, #+0]
   \   00000084   0x280D             CMP      R0,#+13
   \   00000086   0xD101             BNE.N    ??SearchString_9
    273              {
    274                return(FALSE);
   \                     ??SearchString_8: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE00A             B.N      ??SearchString_4
    275              }
    276              
    277              /* If here, match was not found (yet), but as long as there are more characters in pu8TargetChar,
    278              then we can scan again. */
    279              
    280              /* Reset match pointer back to the start of its string */
    281              pu8MatchChar = pu8MatchString_;
   \                     ??SearchString_9: (+1)
   \   0000008C   0x000B             MOVS     R3,R1
    282            } while ( (*pu8TargetChar != NULL) && 
    283                      (*pu8TargetChar != ASCII_LINEFEED) && (*pu8TargetChar != ASCII_CARRIAGE_RETURN) );
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD005             BEQ.N    ??SearchString_10
   \   00000094   0x7820             LDRB     R0,[R4, #+0]
   \   00000096   0x280A             CMP      R0,#+10
   \   00000098   0xD002             BEQ.N    ??SearchString_10
   \   0000009A   0x7820             LDRB     R0,[R4, #+0]
   \   0000009C   0x280D             CMP      R0,#+13
   \   0000009E   0xD1B3             BNE.N    ??SearchString_0
    284            
    285            /* If we get here, no match was found */
    286            return(FALSE);
   \                     ??SearchString_10: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??SearchString_4: (+1)
   \   000000A2   0xBC30             POP      {R4,R5}
   \   000000A4   0x4770             BX       LR               ;; return
    287          
    288          } /* end SearchString */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00
    289          
    290          
    291          /*--------------------------------------------------------------------------------------------------------------------*/
    292          /* Protected Functions */
    293          /*--------------------------------------------------------------------------------------------------------------------*/
    294          
    295          /*--------------------------------------------------------------------------------------------------------------------*/
    296          /* Private functions */
    297          /*--------------------------------------------------------------------------------------------------------------------*/
    298          
    299          
    300          
    301          
    302          /*--------------------------------------------------------------------------------------------------------------------*/
    303          /* End of File */
    304          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ASCIIHexCharToChar
       0   HexToASCIICharLower
       0   HexToASCIICharUpper
      40   NumberToAscii
        40   -> strcpy
       8   SearchString


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      66  ASCIIHexCharToChar
       8  G_au8MessageFAIL
       8  G_au8MessageOFF
       8  G_au8MessageOK
       8  G_au8MessageON
      40  HexToASCIICharLower
      40  HexToASCIICharUpper
     120  NumberToAscii
     166  SearchString

 
  32 bytes in section .data
 436 bytes in section .text
 
 436 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
